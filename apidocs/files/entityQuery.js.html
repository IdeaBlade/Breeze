<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>entityQuery.js - The Breeze API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
<!-- commenting out until beta goes live	<link rel="stylesheet" href="http://breezejs.com/sites/all/themes/omega/alpha/css/apha-reset.css"> 
-->    
	<link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<script type="text/javascript">
  var uvOptions = {};
  (function() {
    var uv = document.createElement('script'); uv.type = 'text/javascript'; uv.async = true;
    uv.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'widget.uservoice.com/GHug452CgVREu58xjoDg.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(uv, s);
  })();
</script>
<div id="wrap">

<div id="doc">
<div class="header">
<div class="logo">
	<a href="http://www.breezejs.com/home"><img src="http://www.breezejs.com/sites/all/themes/breeze/images/breeze_large.png" /></a>
	</div>

    <div class="primary-nav">
<ul>
		
		<li>
			<a href="http://www.breezejs.com/documentation/download" target="_blank">Download</a></li>
		<li>
			<a href="http://learn.breezejs.com/" target="_blank">Tutorials</a></li>	
		<li>
			<a href="http://www.breezejs.com/documentation/introduction">Docs</a></li>
		<li>
			<a href="http://www.breezejs.com/samples">Samples</a></li>
		<li>
			<a href="http://www.breezejs.com/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://stackoverflow.com/questions/tagged/breeze?sort=newest" target="_blank">Forum</a></li>
		<li>
			<a href="http://www.breezejs.com/support" target="_blank">Support</a></li>	
		
	</ul>
</div>
</div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AutoGeneratedKeyType.html">AutoGeneratedKeyType</a></li>
            
                <li><a href="..&#x2F;classes/ComplexAspect.html">ComplexAspect</a></li>
            
                <li><a href="..&#x2F;classes/ComplexType.html">ComplexType</a></li>
            
                <li><a href="..&#x2F;classes/config.html">config</a></li>
            
                <li><a href="..&#x2F;classes/DataProperty.html">DataProperty</a></li>
            
                <li><a href="..&#x2F;classes/DataService.html">DataService</a></li>
            
                <li><a href="..&#x2F;classes/DataType.html">DataType</a></li>
            
                <li><a href="..&#x2F;classes/EntityAction.html">EntityAction</a></li>
            
                <li><a href="..&#x2F;classes/EntityAspect.html">EntityAspect</a></li>
            
                <li><a href="..&#x2F;classes/EntityKey.html">EntityKey</a></li>
            
                <li><a href="..&#x2F;classes/EntityManager.html">EntityManager</a></li>
            
                <li><a href="..&#x2F;classes/EntityQuery.html">EntityQuery</a></li>
            
                <li><a href="..&#x2F;classes/EntityState.html">EntityState</a></li>
            
                <li><a href="..&#x2F;classes/EntityType.html">EntityType</a></li>
            
                <li><a href="..&#x2F;classes/Enum.html">Enum</a></li>
            
                <li><a href="..&#x2F;classes/EnumSymbol.html">EnumSymbol</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/FetchStrategy.html">FetchStrategy</a></li>
            
                <li><a href="..&#x2F;classes/FilterQueryOp.html">FilterQueryOp</a></li>
            
                <li><a href="..&#x2F;classes/LocalQueryComparisonOptions.html">LocalQueryComparisonOptions</a></li>
            
                <li><a href="..&#x2F;classes/MergeStrategy.html">MergeStrategy</a></li>
            
                <li><a href="..&#x2F;classes/MetadataStore.html">MetadataStore</a></li>
            
                <li><a href="..&#x2F;classes/NamingConvention.html">NamingConvention</a></li>
            
                <li><a href="..&#x2F;classes/NavigationProperty.html">NavigationProperty</a></li>
            
                <li><a href="..&#x2F;classes/Predicate.html">Predicate</a></li>
            
                <li><a href="..&#x2F;classes/Promise.html">Promise</a></li>
            
                <li><a href="..&#x2F;classes/QueryOptions.html">QueryOptions</a></li>
            
                <li><a href="..&#x2F;classes/SaveOptions.html">SaveOptions</a></li>
            
                <li><a href="..&#x2F;classes/ValidationError.html">ValidationError</a></li>
            
                <li><a href="..&#x2F;classes/ValidationOptions.html">ValidationOptions</a></li>
            
                <li><a href="..&#x2F;classes/Validator.html">Validator</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_keyGenerator_interface.html">ↈ_keyGenerator_interface</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_relationArray_.html">ↈ_relationArray_</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/breeze.html">breeze</a></li>
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: entityQuery.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
﻿define([&quot;core&quot;, &quot;entityMetadata&quot;, &quot;entityAspect&quot;],
function (core, m_entityMetadata, m_entityAspect) {
    &quot;use strict&quot;;
    &#x2F;**
    @module breeze
    **&#x2F;

    var Enum = core.Enum;
    var assertParam = core.assertParam;
    
    var MetadataStore = m_entityMetadata.MetadataStore;
    var NavigationProperty = m_entityMetadata.NavigationProperty;
    var EntityType = m_entityMetadata.EntityType;
    var DataType = m_entityMetadata.DataType;
    
    var EntityAspect = m_entityAspect.EntityAspect;
    var EntityKey = m_entityAspect.EntityKey;
    
    
    var EntityQuery = (function () {
        &#x2F;**
        An EntityQuery instance is used to query entities either from a remote datasource or from a local {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}}. 

        EntityQueries are immutable - this means that all EntityQuery methods that return an EntityQuery actually create a new EntityQuery.  This means that 
        EntityQueries can be &#x27;modified&#x27; without affecting any current instances.

        @class EntityQuery
        **&#x2F;
            
        &#x2F;**
        @example                    
            var query = new EntityQuery(&quot;Customers&quot;)

        Usually this constructor will be followed by calls to filtering, ordering or selection methods
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
               .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
               .orderBy(&quot;Region&quot;);

        @method &lt;ctor&gt; EntityQuery 
        @param [resourceName] {String}
        **&#x2F;
        var ctor = function (resourceName) {
            assertParam(resourceName, &quot;resourceName&quot;).isOptional().isString().check();
            this.resourceName = normalizeResourceName(resourceName);
            this.entityType = null;
            this.wherePredicate = null;
            this.orderByClause = null;
            this.selectClause = null;
            this.skipCount = null;
            this.takeCount = null;
            this.expandClause = null;
            this.parameters = {};
            this.inlineCountEnabled = false;
            &#x2F;&#x2F; default is to get queryOptions from the entityManager.
            this.queryOptions = null;
            this.entityManager = null;                 
        };
        var proto = ctor.prototype;

        &#x2F;**
        The resource name used by this query.

        __readOnly__
        @property resourceName {String}
        **&#x2F;

        &#x2F;**
        The &#x27;where&#x27; predicate used by this query.

        __readOnly__
        @property wherePredicate {Predicate} 
        **&#x2F;

        &#x2F;**
        The {{#crossLink &quot;OrderByClause&quot;}}{{&#x2F;crossLink}} used by this query.

        __readOnly__
        @property orderByClause {OrderByClause}
        **&#x2F;

        &#x2F;**
        The number of entities to &#x27;skip&#x27; for this query.

        __readOnly__
        @property skipCount {Integer}
        **&#x2F;

        &#x2F;**
        The number of entities to &#x27;take&#x27; for this query.

        __readOnly__
        @property takeCount {Integer}
        **&#x2F;
        
        &#x2F;**
       Any additional parameters that were added to the query via the &#x27;withParameters&#x27; method. 

       __readOnly__
       @property parameters {Object}
       **&#x2F;

        &#x2F;**
        The {{#crossLink &quot;QueryOptions&quot;}}{{&#x2F;crossLink}} for this query.

        __readOnly__
        @property queryOptions {QueryOptions}
        **&#x2F;
        
        &#x2F;**
        The {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}} for this query. This may be null and can be set via the &#x27;using&#x27; method.

        __readOnly__
        @property entityManager {EntityManager}
        **&#x2F;

        &#x2F;*
        Made internal for now.
        @method getEntityType
        @param metadataStore {MetadataStore} The {{#crossLink &quot;MetadataStore&quot;}}{{&#x2F;crossLink}} in which to locate the 
        {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}} returned by this query. 
        @param [throwErrorIfNotFound = false] {Boolean} Whether or not to throw an error if an EntityType cannot be found.
        @return {EntityType} Will return a null if the resource has not yet been resolved and throwErrorIfNotFound is false. 
        *&#x2F;
        proto._getEntityType = function (metadataStore, throwErrorIfNotFound) {
            assertParam(metadataStore, &quot;metadataStore&quot;).isInstanceOf(MetadataStore).check();
            assertParam(throwErrorIfNotFound, &quot;throwErrorIfNotFound&quot;).isBoolean().isOptional().check();
            var entityType = this.entityType;
            if (!entityType) {
                var resourceName = this.resourceName;
                if (!resourceName) {
                    throw new Error(&quot;There is no resourceName for this query&quot;);
                }
                if (metadataStore.isEmpty()) {
                    if (throwErrorIfNotFound) {
                        throw new Error(&quot;There is no metadata available for this query&quot;);
                    } else {
                        return null;
                    }
                }
                var entityTypeName = metadataStore._getEntityTypeNameForResourceName(resourceName);
                if (!entityTypeName) {
                    if (throwErrorIfNotFound) {
                        throw new Error(&quot;Cannot find resourceName of: &quot; + resourceName);
                    } else {
                        return null;
                    }
                }
                entityType = metadataStore.getEntityType(entityTypeName);
                if (!entityType) {
                    if (throwErrorIfNotFound) {
                        throw new Error(&quot;Cannot find an entityType for an entityTypeName of: &quot; + entityTypeName);
                    } else {
                        return null;
                    }
                }
                this.entityType = entityType;
            }
            return entityType;
        };

        &#x2F;**
        Specifies the resource to query for this EntityQuery.
        @example                    
            var query = new EntityQuery()
                .from(&quot;Customers&quot;);
        is the same as 
        @example
            var query = new EntityQuery(&quot;Customers&quot;);
        @method from
        @param resourceName {String} The resource to query.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.from = function (resourceName) {
            &#x2F;&#x2F; TODO: think about allowing entityType as well 
            assertParam(resourceName, &quot;resourceName&quot;).isString().check();
            resourceName = normalizeResourceName(resourceName);
            var currentName = this.resourceName;
            if (currentName &amp;&amp; currentName !== resourceName) {
                throw new Error(&quot;This query already has an resourceName - the resourceName may only be set once per query&quot;);
            }
            var eq = this._clone();
            eq.resourceName = resourceName;
            return eq;
        };
        
        &#x2F;**
        This is a static version of the &quot;from&quot; method and it creates a &#x27;base&#x27; entityQuery for the specified resource name. 
        @example                    
            var query = EntityQuery.from(&quot;Customers&quot;);
        is the same as 
        @example
            var query = new EntityQuery(&quot;Customers&quot;);
        @method from
        @static
        @param resourceName {String} The resource to query.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.from = function (resourceName) {
            assertParam(resourceName, &quot;resourceName&quot;).isString().check();
            return new EntityQuery(resourceName);
        };


        &#x2F;**
        Returns a new query with an added filter criteria. Can be called multiple times which means to &#x27;and&#x27; with any existing Predicate.
        @example                    
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;);
        This can also be expressed using an explicit {{#crossLink &quot;FilterQueryOp&quot;}}{{&#x2F;crossLink}} as
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, FilterQueryOp.StartsWith, &quot;C&quot;);
        or a preconstructed {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}} may be used
        @example
            var pred = new Predicate(&quot;CompanyName&quot;, FilterQueryOp.StartsWith, &quot;C&quot;);
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(pred);
        Predicates are often useful when you want to combine multiple conditions in a single filter, such as
        @example
            var pred = Predicate.create(&quot;CompanyName&quot;, &quot;startswith&quot;, &quot;C&quot;).and(&quot;Region&quot;, FilterQueryOp.Equals, null);
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(pred);
        @example
        More complicated queries can make use of nested property paths
        @example
            var query = new EntityQuery(&quot;Products&quot;)
                .where(&quot;Category.CategoryName&quot;, &quot;startswith&quot;, &quot;S&quot;);
        or OData functions - A list of valid OData functions can be found within the {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}} documentation.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;toLower(CompanyName)&quot;, &quot;startsWith&quot;, &quot;c&quot;);
        or to be even more baroque
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
               .where(&quot;toUpper(substring(CompanyName, 1, 2))&quot;, FilterQueryOp.Equals, &quot;OM&quot;);
        @method where
        @param predicate {Predicate|property|property path, operator, value} Can be either
        
        - a single {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}}

        - or the parameters to create a &#x27;simple&#x27; Predicate

            - a property name, a property path with &#x27;.&#x27; as path seperators or a property expression {String}
            - an operator {FilterQueryOp|String} Either a  {{#crossLink &quot;FilterQueryOp&quot;}}{{&#x2F;crossLink}} or it&#x27;s string representation. Case is ignored
                 when if a string is provided and any string that matches one of the FilterQueryOp aliases will be accepted.
            - a value {Object} - This will be treated as either a property expression or a literal depending on context.  In general, 
                 if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal. 
                 In most cases this works well, but you can also force the interpretation by setting the next parameter &#x27;valueIsLiteral&#x27; to true.
            - an optional [valueIsLiteral] {Boolean} parameter - Used to force the &#x27;value&#x27; parameter to be treated as a literal - otherwise this will be inferred based on the context.

   
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.where = function (predicate) {
            var eq = this._clone();
            if (arguments.length === 0) {
                eq.wherePredicate = null;
                return eq;
            }
            var pred;
            if (Predicate.isPredicate(predicate)) {
                pred = predicate;
            } else {
                pred = Predicate.create(Array.prototype.slice.call(arguments));
            }
            if (eq.entityType) pred.validate(eq.entityType);
            if (eq.wherePredicate) {
                eq.wherePredicate = new CompositePredicate(&#x27;and&#x27;, [eq.wherePredicate, pred]);
            } else {
                eq.wherePredicate = pred;
            }
            return eq;
        };

        &#x2F;**
        Returns a new query that orders the results of the query by property name.  By default sorting occurs is ascending order, but sorting in descending order is supported as well. 
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderBy(&quot;CompanyName&quot;);

        or to sort across multiple properties
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderBy(&quot;Region, CompanyName&quot;);

        Nested property paths are also supported
        @example
             var query = new EntityQuery(&quot;Products&quot;)
                .orderBy(&quot;Category.CategoryName&quot;);

        Sorting in descending order is supported via the addition of &#x27; desc&#x27; to the end of any property path.
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                .orderBy(&quot;CompanyName desc&quot;);

        or
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                .orderBy(&quot;Region desc, CompanyName desc&quot;);
        @method orderBy
        @param propertyPaths {String|Array of String} A comma-separated (&#x27;,&#x27;) string of property paths or an array of property paths. Each property path can optionally end with &quot; desc&quot; to force a descending sort order.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.orderBy = function (propertyPaths) {
            &#x2F;&#x2F; deliberately don&#x27;t pass in isDesc
            return orderByCore(this, normalizePropertyPaths(propertyPaths));
        };

        &#x2F;**
        Returns a new query that orders the results of the query by property name in descending order.
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderByDesc(&quot;CompanyName&quot;);

        or to sort across multiple properties
        @example
             var query = new EntityQuery(&quot;Customers&quot;)
                 .orderByDesc(&quot;Region, CompanyName&quot;);

        Nested property paths are also supported
        @example
             var query = new EntityQuery(&quot;Products&quot;)
                .orderByDesc(&quot;Category.CategoryName&quot;);

        @method orderByDesc
        @param propertyPaths {String|Array of String} A comma-separated (&#x27;,&#x27;) string of property paths or an array of property paths.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.orderByDesc = function (propertyPaths) {
            return orderByCore(this, normalizePropertyPaths(propertyPaths), true);
        };
        
        &#x2F;**
        Returns a new query that selects a list of properties from the results of the original query and returns the values of just these properties. This
        will be referred to as a projection. 
        If the result of this selection &quot;projection&quot; contains entities, these entities will automatically be added to EntityManager&#x27;s cache and will 
        be made &#x27;observable&#x27;.
        Any simple properties, i.e. strings, numbers or dates within a projection will not be cached are will NOT be made &#x27;observable&#x27;.
        
        @example
        Simple data properties can be projected
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .select(&quot;CompanyName&quot;);
        This will return an array of objects each with a single &quot;CompanyName&quot; property of type string.
        A similar query could return a navigation property instead
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .select(&quot;Orders&quot;);
        where the result would be an array of objects each with a single &quot;Orders&quot; property that would itself be an array of &quot;Order&quot; entities.
        Composite projections are also possible:
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .select(&quot;CompanyName, Orders&quot;);
        As well as projections involving nested property paths
        @example
            var query = EntityQuery(&quot;Orders&quot;)
                .where(&quot;Customer.CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)         
                .select(&quot;Customer.CompanyName, Customer, OrderDate&quot;);
        @method select
        @param propertyPaths {String|Array of String} A comma-separated (&#x27;,&#x27;) string of property paths or an array of property paths.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.select = function (propertyPaths) {
            return selectCore(this, normalizePropertyPaths(propertyPaths));
        };


        &#x2F;**
        Returns a new query that skips the specified number of entities when returning results.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
               .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
               .skip(5);
        @method skip
        @param count {Number} The number of entities to return. If omitted this clears the 
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.skip = function (count) {
            assertParam(count, &quot;count&quot;).isOptional().isNumber().check();
            var eq = this._clone();
            if (arguments.length === 0) {
                eq.skipCount = null;
            } else {
                eq.skipCount = count;
            }
            return eq;
        };
        
        &#x2F;**
        Returns a new query that returns only the specified number of entities when returning results. - Same as &#x27;take&#x27;.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .top(5);
        @method top
        @param count {Number} The number of entities to return.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.top = function(count) {
            return this.take(count);
        };

        &#x2F;**
        Returns a new query that returns only the specified number of entities when returning results - Same as &#x27;top&#x27;
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .take(5);
        @method take
        @param count {Number} The number of entities to return.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.take = function (count) {
            assertParam(count, &quot;count&quot;).isOptional().isNumber().check();
            var eq = this._clone();
            if (arguments.length === 0) {
                eq.takeCount = null;
            } else {
                eq.takeCount = count;
            }
            return eq;
        };
        
        &#x2F;**
        Returns a new query that will return related entities nested within its results. The expand method allows you to identify related entities, via navigation property
        names such that a graph of entities may be retrieved with a single request. Any filtering occurs before the results are &#x27;expanded&#x27;.
        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .where(&quot;CompanyName&quot;, &quot;startsWith&quot;, &quot;C&quot;)
                .expand(&quot;Orders&quot;);
        will return the filtered customers each with its &quot;Orders&quot; properties fully resolved.
        Multiple paths may be specified by separating the paths by a &#x27;,&#x27;
        @example
            var query = new EntityQuery(&quot;Orders&quot;)
                .expand(&quot;Customer, Employee&quot;)
        and nested property paths my be specified as well
        @example
            var query = new EntityQuery(&quot;Orders&quot;)
                .expand(&quot;Customer, OrderDetails, OrderDetails.Product&quot;)
        @method expand
        @param propertyPaths {String|Array of String} A comma-separated list of navigation property names or an array of navigation property names. Each Navigation Property name can be followed
        by a &#x27;.&#x27; and another navigation property name to enable identifying a multi-level relationship
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.expand = function (propertyPaths) {
            return expandCore(this, normalizePropertyPaths(propertyPaths));
        };

        &#x2F;**
        Returns a new query that includes a collection of parameters to pass to the server.
        @example
            var query = EntityQuery.from(&quot;EmployeesFilteredByCountryAndBirthdate&quot;)
                .withParameters({ BirthDate: &quot;1&#x2F;1&#x2F;1960&quot;, Country: &quot;USA&quot; });
        will call the &#x27;EmployeesFilteredByCountryAndBirthdata&#x27; method on the server and pass in 2 parameters. This
        query will be uri encoded as 

            {serviceApi}&#x2F;EmployeesFilteredByCountryAndBirthdate?birthDate=1%2F1%2F1960&amp;country=USA
        
        Parameters may also be mixed in with other query criteria.
        @example
             var query = EntityQuery.from(&quot;EmployeesFilteredByCountryAndBirthdate&quot;)
                .withParameters({ BirthDate: &quot;1&#x2F;1&#x2F;1960&quot;, Country: &quot;USA&quot; })
                .where(&quot;LastName&quot;, &quot;startsWith&quot;, &quot;S&quot;)
                .orderBy(&quot;BirthDate&quot;);
        
        @method withParameters
        @param parameters {Object} A parameters object where the keys are the parameter names and the values are the parameter values. 
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.withParameters = function(parameters) {
            assertParam(parameters, &quot;parameters&quot;).isObject().check();
            return withParametersCore(this, parameters);
        };

        &#x2F;**
        Returns a query with the &#x27;inlineCount&#x27; capability either enabled or disabled.  With &#x27;inlineCount&#x27; enabled, an additional &#x27;inlineCount&#x27; property
        will be returned with the query results that will contain the number of entities that would have been returned by this
        query with only the &#x27;where&#x27;&#x2F;&#x27;filter&#x27; clauses applied, i.e. without any &#x27;skip&#x27;&#x2F;&#x27;take&#x27; operators applied. For local queries this clause is ignored. 

        @example
            var query = new EntityQuery(&quot;Customers&quot;)
                .take(20)
                .orderBy(&quot;CompanyName&quot;)
                .inlineCount(true);
        will return the first 20 customers as well as a count of all of the customers in the remote store.

        @method inlineCount
        @param enabled {Boolean=true} Whether or not inlineCount capability should be enabled. If this parameter is omitted, true is assumed. 
        @return {EntityQuery}
        @chainable
        **&#x2F;
        proto.inlineCount = function(enabled) {
            if (enabled === undefined) enabled = true;
            var eq = this._clone();
            eq.inlineCountEnabled = enabled;
            return eq;
        };

         &#x2F;&#x2F; Implementations found in EntityManager
        &#x2F;**
        Returns a copy of this EntityQuery with the specified {{#crossLink &quot;EntityManager&quot;}}{{&#x2F;crossLink}}, {{#crossLink &quot;MergeStrategy&quot;}}{{&#x2F;crossLink}} 
        or {{#crossLink &quot;FetchStrategy&quot;}}{{&#x2F;crossLink}} applied.
        @example
        &#x27;using&#x27; can be used to return a new query with a specified EntityManager.
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;)
                 .using(em);
        or with a specified {{#crossLink &quot;MergeStrategy&quot;}}{{&#x2F;crossLink}} 
        @example
            var em = new EntityManager(serviceName);
            var query = new EntityQuery(&quot;Orders&quot;)
                .using(MergeStrategy.PreserveChanges);
        or with a specified {{#crossLink &quot;FetchStrategy&quot;}}{{&#x2F;crossLink}} 
        @example
            var em = new EntityManager(serviceName);
            var query = new EntityQuery(&quot;Orders&quot;)
                .using(FetchStrategy.FromLocalCache);
        @example
        @method using
        @param obj {EntityManager|MergeStrategy|FetchStrategy} The object to update in creating a new EntityQuery from an existing one.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        
        &#x2F;&#x2F; Implementations found in EntityManager
        &#x2F;**
        Executes this query.  This method requires that an EntityManager have been previously specified via the &quot;using&quot; method.
        @example
        This method can be called using a &#x27;promises&#x27; syntax ( recommended)
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;).using(em);
             query.execute()
               .then( function(data) {
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
        or with callbacks
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;).using(em);
             query.execute(
                function(data) {
                   var orders = data.results;
                   ... query results processed here
                },
                function(err) {
                   ... query failure processed here
                });
        Either way this method is the same as calling the EntityManager &#x27;execute&#x27; method.
        @example
             var em = new EntityManager(serviceName);
             var query = new EntityQuery(&quot;Orders&quot;);
             em.executeQuery(query)
               .then( function(data) {
                   var orders = data.results;
                   ... query results processed here
             }).fail( function(err) {
                   ... query failure processed here
             });
         
        @method execute
        @async
        
        @param callback {Function} Function called on success.
        
            successFunction([data])
            @param [callback.data] {Object} 
            @param callback.data.results {Array of Entity}
            @param callback.data.query {EntityQuery} The original query
            @param callback.data.XHR {XMLHttpRequest} The raw XMLHttpRequest returned from the server.
            @param callback.data.inlineCount {Integer} Only available if &#x27;inlineCount(true)&#x27; was applied to the query.  Returns the count of 
            items that would have been returned by the query before applying any skip or take operators, but after any filter&#x2F;where predicates
            would have been applied. 

        @param errorCallback {Function} Function called on failure.
            
            failureFunction([error])
            @param [errorCallback.error] {Error} Any error that occured wrapped into an Error object.
            @param [errorCallback.error.query] The query that caused the error.
            @param [errorCallback.error.XHR] {XMLHttpRequest} The raw XMLHttpRequest returned from the server.

        @return {Promise}
        **&#x2F;
        
        &#x2F;**
        Executes this query against the local cache.  This method requires that an EntityManager have been previously specified via the &quot;using&quot; method.
        @example
            &#x2F;&#x2F; assume em is an entityManager already filled with order entities;
            var query = new EntityQuery(&quot;Orders&quot;).using(em);
            var orders = query.executeLocally();
        
        Note that calling this method is the same as calling {{#crossLink &quot;EntityManager&#x2F;executeQueryLocally&quot;}}{{&#x2F;crossLink}}.
      
        @method executeLocally
        **&#x2F;

        &#x2F;**
        Static method tht creates an EntityQuery that will allow &#x27;requerying&#x27; an entity or a collection of entities by primary key. This can be useful
        to force a requery of selected entities, or to restrict an existing collection of entities according to some filter.
        @example
            &#x2F;&#x2F; assuming &#x27;customers&#x27; is an array of &#x27;Customer&#x27; entities retrieved earlier.
            var customersQuery = EntityQuery.fromEntities(customers);
        The resulting query can, of course, be extended
        @example
            &#x2F;&#x2F; assuming &#x27;customers&#x27; is an array of &#x27;Customer&#x27; entities retrieved earlier.
            var customersQuery = EntityQuery.fromEntities(customers)
                .where(&quot;Region&quot;, FilterQueryOp.NotEquals, null);
        Single entities can requeried as well.
        @example
            &#x2F;&#x2F; assuming &#x27;customer&#x27; is a &#x27;Customer&#x27; entity retrieved earlier.
            var customerQuery = EntityQuery.fromEntities(customer);
        will create a query that will return an array containing a single customer entity.
        @method fromEntities
        @static
        @param entities {Entity|Array of Entity} The entities for which we want to create an EntityQuery.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.fromEntities = function (entities) {
            assertParam(entities, &quot;entities&quot;).isEntity().or().isNonEmptyArray().isEntity().check();
            if (!Array.isArray(entities)) {
                entities = Array.prototype.slice.call(arguments);
            }
            var firstEntity = entities[0];
            var q = new EntityQuery(firstEntity.entityType.defaultResourceName);
            var preds = entities.map(function (entity) {
                return buildPredicate(entity);
            });
            var pred = Predicate.or(preds);
            q = q.where(pred);
            var em = firstEntity.entityAspect.entityManager;
            if (em) {
                q = q.using(em);
            }
            return q;
        };

        &#x2F;**
        Creates an EntityQuery for the specified {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}}.
        @example
            var empType = metadataStore.getEntityType(&quot;Employee&quot;);
            var entityKey = new EntityKey(empType, 1);
            var query = EntityQuery.fromEntityKey(entityKey);
        or
        @example
            &#x2F;&#x2F; &#x27;employee&#x27; is a previously queried employee
            var entityKey = employee.entityAspect.getKey();
            var query = EntityQuery.fromEntityKey(entityKey);
        @method fromEntityKey
        @static
        @param entityKey {EntityKey} The {{#crossLink &quot;EntityKey&quot;}}{{&#x2F;crossLink}} for which a query will be created.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.fromEntityKey = function (entityKey) {
            assertParam(entityKey, &quot;entityKey&quot;).isInstanceOf(EntityKey).check();
            var q = new EntityQuery(entityKey.entityType.defaultResourceName);
            var pred = buildKeyPredicate(entityKey);
            q = q.where(pred);
            return q;
        };

        &#x2F;**
        Creates an EntityQuery for the specified entity and {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}}.
        @example
            &#x2F;&#x2F; &#x27;employee&#x27; is a previously queried employee
            var ordersNavProp = employee.entityType.getProperty(&quot;Orders&quot;);
            var query = EntityQuery.fromEntityNavigation(employee, ordersNavProp);
        will return a query for the &quot;Orders&quot; of the specified &#x27;employee&#x27;.
        @method fromEntityNavigation
        @static
        @param entity {Entity} The Entity whose navigation property will be queried.
        @param navigationProperty {NavigationProperty} The {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}} to be queried.
        @return {EntityQuery}
        @chainable
        **&#x2F;
        ctor.fromEntityNavigation = function (entity, navigationProperty) {
            assertParam(entity, &quot;entity&quot;).isEntity().check();
            assertParam(navigationProperty, &quot;navigationProperty&quot;).isInstanceOf(NavigationProperty).check();
            var navProperty = entity.entityType._checkNavProperty(navigationProperty);
            var q = new EntityQuery(navProperty.entityType.defaultResourceName);
            var pred = buildNavigationPredicate(entity, navProperty);
            q = q.where(pred);
            var em = entity.entityAspect.entityManager;
            if (em) {
                q = q.using(em);
            }
            return q;
        };


        &#x2F;&#x2F; protected methods

        proto._clone = function () {
            var copy = new EntityQuery();
            copy.resourceName = this.resourceName;
            copy.entityType = this.entityType;
            copy.wherePredicate = this.wherePredicate;
            copy.orderByClause = this.orderByClause;
            copy.selectClause = this.selectClause;
            copy.skipCount = this.skipCount;
            copy.takeCount = this.takeCount;
            copy.expandClause = this.expandClause;
            copy.inlineCountEnabled = this.inlineCountEnabled;
            copy.parameters = core.extend({}, this.parameters);
            &#x2F;&#x2F; default is to get queryOptions from the entityManager.
            copy.queryOptions = this.queryOptions;
            copy.entityManager = this.entityManager;

            return copy;
        };

        &#x2F;&#x2F; OData QueryOptions - currently supports filter, orderBy, skip, top and expand.
        &#x2F;&#x2F;        $filter    - done
        &#x2F;&#x2F;        $select
        &#x2F;&#x2F;        $orderBy   - done
        &#x2F;&#x2F;        $top       - done
        &#x2F;&#x2F;        $skip      - done
        &#x2F;&#x2F;        $format
        &#x2F;&#x2F;        $expand    - done
        &#x2F;&#x2F;        $inlinecount

        proto._toUri = function (metadataStore) {
            &#x2F;&#x2F; force entityType validation;
            var entityType = this._getEntityType(metadataStore, false);
            if (!entityType) {
                entityType = new EntityType(metadataStore);
            }

            var eq = this;
            var queryOptions = {};
            queryOptions[&quot;$filter&quot;] = toFilterString();
            queryOptions[&quot;$orderby&quot;] = toOrderByString();
            queryOptions[&quot;$skip&quot;] = toSkipString();
            queryOptions[&quot;$top&quot;] = toTopString();
            queryOptions[&quot;$expand&quot;] = toExpandString();
            queryOptions[&quot;$select&quot;] = toSelectString();
            queryOptions[&quot;$inlinecount&quot;] = toInlineCountString();
            queryOptions = core.extend(queryOptions, this.parameters);
            
            var qoText = toQueryOptionsString(queryOptions);
            return this.resourceName + qoText;

            &#x2F;&#x2F; private methods to this func.

            function toFilterString() {
                var clause = eq.wherePredicate;
                if (!clause) return &quot;&quot;;
                if (eq.entityType) {
                    clause.validate(eq.entityType);
                }
                return clause.toOdataFragment(entityType);
            }
            
            function toInlineCountString() {
                if (!eq.inlineCountEnabled) return &quot;&quot;;
                return eq.inlineCountEnabled ? &quot;allpages&quot; : &quot;none&quot;;
            }

            function toOrderByString() {
                var clause = eq.orderByClause;
                if (!clause) return &quot;&quot;;
                if (eq.entityType) {
                    clause.validate(eq.entityType);
                }
                return clause.toOdataFragment(entityType);
            }
            
             function toSelectString() {
                var clause = eq.selectClause;
                if (!clause) return &quot;&quot;;
                if (eq.entityType) {
                    clause.validate(eq.entityType);
                }
                return clause.toOdataFragment(entityType);
            }
            
            function toExpandString() {
                var clause = eq.expandClause;
                if (!clause) return &quot;&quot;;
                return clause.toOdataFragment(entityType);
            }

            function toSkipString() {
                var count = eq.skipCount;
                if (!count) return &quot;&quot;;
                return count.toString();
            }

            function toTopString() {
                var count = eq.takeCount;
                if (!count) return &quot;&quot;;
                return count.toString();
            }

            function toQueryOptionsString(queryOptions) {
                var qoStrings = [];
                for (var qoName in queryOptions) {
                    var qoValue = queryOptions[qoName];
                    if (qoValue) {
                        qoStrings.push(qoName + &quot;=&quot; + encodeURIComponent(qoValue));
                    }
                }

                if (qoStrings.length &gt; 0) {
                    return &quot;?&quot; + qoStrings.join(&quot;&amp;&quot;);
                } else {
                    return &quot;&quot;;
                }
            }
        };

        proto._toFilterFunction = function (entityType) {
            var wherePredicate = this.wherePredicate;
            if (!wherePredicate) return null;
            &#x2F;&#x2F; may throw an exception
            wherePredicate.validate(entityType);
            return wherePredicate.toFunction(entityType);
        };

        proto._toOrderByComparer = function (entityType) {
            var orderByClause = this.orderByClause;
            if (!orderByClause) return null;
            &#x2F;&#x2F; may throw an exception
            orderByClause.validate(entityType);
            return orderByClause.getComparer();
        };

        &#x2F;&#x2F; private functions
        
        function normalizeResourceName(resourceName) {
            return resourceName;
&#x2F;&#x2F;            if (resourceName) {
&#x2F;&#x2F;                return resourceName.toLowerCase();
&#x2F;&#x2F;            } else {
&#x2F;&#x2F;                return undefined;
&#x2F;&#x2F;            }
        }
        
        function normalizePropertyPaths(propertyPaths) {
            assertParam(propertyPaths, &quot;propertyPaths&quot;).isOptional().isString().or().isArray().isString().check();
            if (typeof propertyPaths === &#x27;string&#x27;) {
                propertyPaths = propertyPaths.split(&quot;,&quot;);
            }

            propertyPaths = propertyPaths.map(function (pp) {
                return pp.trim();
            });
            return propertyPaths;
        }


        function buildPredicate(entity) {
            var entityType = entity.entityType;
            var predParts = entityType.keyProperties.map(function (kp) {
                return Predicate.create(kp.name, FilterQueryOp.Equals, entity.getProperty(kp.name));
            });
            var pred = Predicate.and(predParts);
            return pred;
        }

        &#x2F;&#x2F; propertyPaths: can pass in create(&quot;A.X,B&quot;) or create(&quot;A.X desc, B&quot;) or create(&quot;A.X desc,B&quot;, true])
        &#x2F;&#x2F; isDesc parameter trumps isDesc in propertyName.

        function orderByCore(that, propertyPaths, isDesc) {
            var newClause;
            var eq = that._clone();
            if (!propertyPaths) {
                eq.orderByClause = null;
                return eq;
            }

            newClause = OrderByClause.create(propertyPaths, isDesc);

            if (eq.orderByClause) {
                eq.orderByClause.addClause(newClause);
            } else {
                eq.orderByClause = newClause;
            }
            return eq;
        }
        
        function selectCore(that, propertyPaths) {
            var eq = that._clone();
            if (!propertyPaths) {
                eq.selectClause = null;
                return eq;
            }
            eq.selectClause = new SelectClause(propertyPaths);
            return eq;
        }
        
        function expandCore(that, propertyPaths) {
            var eq = that._clone();
            if (!propertyPaths) {
                eq.expandClause = null;
                return eq;
            }
            eq.expandClause = new ExpandClause(propertyPaths);
            return eq;
        }
        
        function withParametersCore(that, parameters) {
            var eq = that._clone();
            eq.parameters = parameters;
            return eq;
        }

        function buildKeyPredicate(entityKey) {
            var keyProps = entityKey.entityType.keyProperties;
            var preds = core.arrayZip(keyProps, entityKey.values, function (kp, v) {
                return Predicate.create(kp.name, FilterQueryOp.Equals, v);
            });
            var pred = Predicate.and(preds);
            return pred;
        }

        function buildNavigationPredicate(entity, navigationProperty) {
            if (navigationProperty.isScalar) {
                if (navigationProperty.foreignKeyNames.length === 0) return null;
                var relatedKeyValues = navigationProperty.foreignKeyNames.map(function (fkName) {
                    return entity.getProperty(fkName);
                });
                var entityKey = new EntityKey(navigationProperty.entityType, relatedKeyValues);
                return buildKeyPredicate(entityKey);
            } else {
                var inverseNp = navigationProperty.inverse;
                if (!inverseNp) return null;
                var foreignKeyNames = inverseNp.foreignKeyNames;
                if (foreignKeyNames.length === 0) return null;
                var keyValues = entity.entityAspect.getKey().values;
                var predParts = core.arrayZip(foreignKeyNames, keyValues, function (fkName, kv) {
                    return Predicate.create(fkName, FilterQueryOp.Equals, kv);
                });
                var pred = Predicate.and(predParts);
                return pred;
            }
        }

        return ctor;
    })();

    var QueryFuncs = (function() {
        var obj = {
            toupper:     { fn: function (source) { return source.toUpperCase(); }, dataType: DataType.String },
            tolower:     { fn: function (source) { return source.toLowerCase(); }, dataType: DataType.String },
            substring:   { fn: function (source, pos, length) { return source.substring(pos, length); }, dataType: DataType.String },
            substringof: { fn: function (find, source) { return source.indexOf(find) &gt;= 0;}, dataType: DataType.Boolean },
            length:      { fn: function(source) { return source.length; }, dataType: DataType.Int32 },
            trim:        { fn: function (source) { return source.trim(); }, dataType: DataType.String },
            concat:      { fn: function (s1, s2) { return s1.concat(s2); }, dataType: DataType.String },
            replace:     { fn: function (source, find, replace) { return source.replace(find, replace); }, dataType: DataType.String },
            startswith:  { fn: function (source, find) { return core.stringStartsWith(source, find); }, dataType: DataType.Boolean },
            endswith:    { fn: function (source, find) { return core.stringEndsWith(source, find); }, dataType: DataType.Boolean },
            indexof:     { fn: function (source, find) { return source.indexOf(find); }, dataType: DataType.Int32 },
            round:       { fn: function (source) { return Math.round(source); }, dataType: DataType.Int32 },
            ceiling:     { fn: function (source) { return Math.ceil(source); }, dataType: DataType.Int32 },
            floor:       { fn: function (source) { return Math.floor(source); }, dataType: DataType.Int32 },
            second:      { fn: function (source) { return source.second; }, dataType: DataType.Int32 },
            minute:      { fn: function (source) { return source.minute; }, dataType: DataType.Int32 },
            day:         { fn: function (source) { return source.day; }, dataType: DataType.Int32 },
            month:       { fn: function (source) { return source.month; }, dataType: DataType.Int32 },
            year:        { fn: function (source) { return source.year; }, dataType: DataType.Int32 },
        };
        
        return obj;
    })();
    
    var FnNode = (function() {
        &#x2F;&#x2F; valid property name identifier
        var RX_IDENTIFIER = &#x2F;^[a-z_][\w.$]*$&#x2F;i ;
        &#x2F;&#x2F; comma delimited expressions ignoring commas inside of quotes.
        var RX_COMMA_DELIM1 = &#x2F;(&#x27;[^&#x27;]*&#x27;|[^,]+)&#x2F;g ;
        var RX_COMMA_DELIM2 = &#x2F;(&quot;[^&quot;]*&quot;|[^,]+)&#x2F;g ;
        
        var ctor = function (source, tokens, entityType) {
            var parts = source.split(&quot;:&quot;);
            if (entityType) {
                this.isValidated = true;
            }
            if (parts.length == 1) {
                var value = parts[0].trim();
                this.value = value;
                &#x2F;&#x2F; value is either a string, a quoted string, a number, a bool value, or a date
                &#x2F;&#x2F; if a string ( not a quoted string) then this represents a property name.
                var firstChar = value.substr(0,1);
                var quoted = firstChar == &quot;&#x27;&quot; || firstChar == &#x27;&quot;&#x27;;
                if (quoted) {
                    var unquoted = value.substr(1, value.length - 2);
                    this.fn = function (entity) { return unquoted; };
                    this.dataType = DataType.String;
                } else {
                    var mayBeIdentifier = RX_IDENTIFIER.test(value);
                    if (mayBeIdentifier) {
                        if (entityType) {
                            if (entityType.getProperty(value, false) == null) {
                                &#x2F;&#x2F; not a real FnNode;
                                this.isValidated = false;
                                return;
                            }
                        }
                        this.propertyPath = value;
                        this.fn = createPropFunction(value);
                    } else {
                        if (entityType) {
                            this.isValidated = false;
                            return;
                        }
                        this.fn = function (entity) { return value; };
                        this.dataType = DataType.fromValue(value);
                    }
                } 
            } else {
                try {
                    this.fnName = parts[0].trim().toLowerCase();
                    var qf = QueryFuncs[this.fnName];
                    this.localFn = qf.fn;
                    this.dataType = qf.dataType;
                    var that = this;
                    this.fn = function(entity) {
                        var resolvedNodes = that.fnNodes.map(function(fnNode) {
                            var argVal = fnNode.fn(entity);
                            return argVal;
                        });
                        var val = that.localFn.apply(null, resolvedNodes);
                        return val;
                    };
                    var argSource = tokens[parts[1]].trim();
                    if (argSource.substr(0, 1) == &quot;(&quot;) {
                        argSource = argSource.substr(1, argSource.length - 2);
                    }
                    var commaMatchStr = source.indexOf(&quot;&#x27;&quot;) &gt;= 0 ? RX_COMMA_DELIM1 : RX_COMMA_DELIM2;
                    var args = argSource.match(commaMatchStr);
                    this.fnNodes = args.map(function(a) {
                        return new FnNode(a, tokens);
                    });
                } catch (e) {
                    this.isValidated = false;
                }
            }
        };
        var proto = ctor.prototype;

        ctor.create = function (source, entityType) {
            if (typeof source !== &#x27;string&#x27;) {
                return null;
            }
            var regex = &#x2F;\([^()]*\)&#x2F; ;
            var m;
            var tokens = [];
            var i = 0;
            while (m = regex.exec(source)) {
                var token = m[0];
                tokens.push(token);
                var repl = &quot;:&quot; + i++;
                source = source.replace(token, repl);
            }
            var node = new FnNode(source, tokens, entityType);
            &#x2F;&#x2F; isValidated may be undefined
            return node.isValidated === false ? null : node;
        };

        proto.toString = function() {
            if (this.fnName) {
                var args = this.fnNodes.map(function(fnNode) {
                    return fnNode.toString();
                });
                var uri = this.fnName + &quot;(&quot; + args.join(&quot;,&quot;) + &quot;)&quot;;
                return uri;
            } else {
                return this.value;
            }
        };

        proto.updateWithEntityType = function(entityType) {
            if (this.propertyPath) {
                if (entityType.isAnonymous) return;
                var prop = entityType.getProperty(this.propertyPath);
                if (!prop) {
                    var msg = core.formatString(&quot;Unable to resolve propertyPath.  EntityType: &#x27;%1&#x27;   PropertyPath: &#x27;%2&#x27;&quot;, entityType.name, this.propertyPath);
                    throw new Error(msg);
                }
                this.dataType = prop.dataType;
            }
        };

        proto.toOdataFragment = function (entityType) {
            this.updateWithEntityType(entityType);
            if (this.fnName) {
                var args = this.fnNodes.map(function(fnNode) {
                    return fnNode.toOdataFragment(entityType);
                });                
                var uri = this.fnName + &quot;(&quot; + args.join(&quot;,&quot;) + &quot;)&quot;;
                return uri;
            } else {
                var firstChar = this.value.substr(0, 1);
                if (firstChar === &quot;&#x27;&quot; || firstChar === &#x27;&quot;&#x27;) {
                    return this.value;                  
                } else if (this.value == this.propertyPath) {
                    return entityType._clientPropertyPathToServer(this.propertyPath);
                } else {
                    return this.value;
                }
            }
        };

        proto.validate = function(entityType) {
            &#x2F;&#x2F; will throw if not found;
            if (this.isValidated !== undefined) return;            
            this.isValidated = true;
            if (this.propertyPath) {
                var prop = entityType.getProperty(this.propertyPath, true);
                if (prop.isDataProperty) {
                    this.dataType = prop.dataType;
                } else {
                    this.dataType = prop.entityType;
                }
            } else if (this.fnNodes) {
                this.fnNodes.forEach(function(node) {
                    node.validate(entityType);
                });
            }
        };
        

        return ctor;
    })();
   
    var FilterQueryOp = function () {
        &#x2F;**
        FilterQueryOp is an &#x27;Enum&#x27; containing all of the valid  {{#crossLink &quot;Predicate&quot;}}{{&#x2F;crossLink}} 
        filter operators for an {{#crossLink &quot;EntityQuery&quot;}}{{&#x2F;crossLink}}.

        @class FilterQueryOp
        @static
        **&#x2F;
        var aEnum = new Enum(&quot;FilterQueryOp&quot;);
        &#x2F;**
        Aliases: &quot;eq&quot;, &quot;==&quot;
        @property Equals {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.Equals = aEnum.addSymbol({ operator: &quot;eq&quot;, aliases: [&quot;==&quot;] });
        &#x2F;**
        Aliases: &quot;ne&quot;, &quot;!=&quot;
        @property NotEquals {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.NotEquals = aEnum.addSymbol({ operator: &quot;ne&quot;, aliases: [&quot;!=&quot;] });
        &#x2F;**
        Aliases: &quot;gt&quot;, &quot;&gt;&quot;
        @property GreaterThan {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.GreaterThan = aEnum.addSymbol({ operator: &quot;gt&quot;, aliases: [&quot;&gt;&quot;] });
        &#x2F;**
        Aliases: &quot;lt&quot;, &quot;&lt;&quot;
        @property LessThan {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.LessThan = aEnum.addSymbol({ operator: &quot;lt&quot;, aliases: [&quot;&lt;&quot;] });
        &#x2F;**
        Aliases: &quot;ge&quot;, &quot;&gt;=&quot;
        @property GreaterThanOrEqual {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.GreaterThanOrEqual = aEnum.addSymbol({ operator: &quot;ge&quot;, aliases: [&quot;&gt;=&quot;] });
        &#x2F;**
        Aliases: &quot;le&quot;, &quot;&lt;=&quot;
        @property LessThanOrEqual {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.LessThanOrEqual = aEnum.addSymbol({ operator: &quot;le&quot;, aliases: [&quot;&lt;=&quot;] });
        &#x2F;**
        String operation: Is a string a substring of another string.
        Aliases: &quot;substringof&quot;
        @property Contains {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.Contains = aEnum.addSymbol({ operator: &quot;substringof&quot;, isFunction: true });
        &#x2F;**
        @property StartsWith {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.StartsWith = aEnum.addSymbol({ operator: &quot;startswith&quot;, isFunction: true });
        &#x2F;**
        @property EndsWith {FilterQueryOp}
        @final
        @static
        **&#x2F;
        aEnum.EndsWith = aEnum.addSymbol({ operator: &quot;endswith&quot;, isFunction: true });
        aEnum.seal();
        aEnum._map = function () {
            var map = {};
            aEnum.getSymbols().forEach(function (s) {
                map[s.name.toLowerCase()] = s;
                map[s.operator.toLowerCase()] = s;
                if (s.aliases) {
                    s.aliases.forEach(function (alias) {
                        map[alias.toLowerCase()] = s;
                    });
                }
            });
            return map;
        } ();
        aEnum.from = function (op) {
            if (aEnum.contains(op)) {
                return op;
            } else {
                return aEnum._map[op.toLowerCase()];
            }
        };
        return aEnum;
    } ();

    var BooleanQueryOp = function () {
        var aEnum = new Enum(&quot;BooleanQueryOp&quot;);
        aEnum.And = aEnum.addSymbol({ operator: &quot;and&quot;, aliases: [&quot;&amp;&amp;&quot;] });
        aEnum.Or = aEnum.addSymbol({ operator: &quot;or&quot;, aliases: [&quot;||&quot;] });
        aEnum.Not = aEnum.addSymbol({ operator: &quot;not&quot;, aliases: [&quot;~&quot;, &quot;!&quot;] });

        aEnum.seal();
        aEnum._map = function () {
            var map = {};
            aEnum.getSymbols().forEach(function (s) {
                map[s.name.toLowerCase()] = s;
                map[s.operator.toLowerCase()] = s;
                if (s.aliases) {
                    s.aliases.forEach(function (alias) {
                        map[alias.toLowerCase()] = s;
                    });
                }
            });
            return map;
        } ();
        aEnum.from = function (op) {
            if (aEnum.contains(op)) {
                return op;
            } else {
                return aEnum._map[op.toLowerCase()];
            }
        };
        return aEnum;
    } ();

    var Predicate = (function () {
        &#x2F;**  
        Used to define a &#x27;where&#x27; predicate for an EntityQuery.  Predicates are immutable, which means that any
        method that would modify a Predicate actually returns a new Predicate. 
        @class Predicate
        **&#x2F;
        
        &#x2F;**
        Predicate constructor
        @example
            var p1 = new Predicate(&quot;CompanyName&quot;, &quot;StartsWith&quot;, &quot;B&quot;);
            var query = new EntityQuery(&quot;Customers&quot;).where(p1);
        or 
        @example
            var p2 = new Predicate(&quot;Region&quot;, FilterQueryOp.Equals, null);
            var query = new EntityQuery(&quot;Customers&quot;).where(p2);
        @method &lt;ctor&gt; Predicate
        @param property {String} A property name, a nested property name or an expression involving a property name.
        @param operator {FilterQueryOp|String}
        @param value {Object} - This will be treated as either a property expression or a literal depending on context.  In general, 
                 if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal. 
                 In most cases this works well, but you can also force the interpretation by setting the next parameter &#x27;valueIsLiteral&#x27; to true.
        @param [valueIsLiteral] {Boolean} - Used to force the &#x27;value&#x27; parameter to be treated as a literal - otherwise this will be inferred based on the context.
        **&#x2F;
        var ctor = function (propertyOrExpr, operator, value, valueIsLiteral) {
            if (arguments[0].prototype === true) {
                &#x2F;&#x2F; used to construct prototype
                return this;
            }
            return new SimplePredicate(propertyOrExpr, operator, value, valueIsLiteral);
        };
        var proto = ctor.prototype;

        &#x2F;**  
        Returns whether an object is a Predicate
        @example
            var p1 = new Predicate(&quot;CompanyName&quot;, &quot;StartsWith&quot;, &quot;B&quot;);
            if (Predicate.isPredicate(p1)) {
                &#x2F;&#x2F; do something
            }
        @method isPredicate
        @param o {Object}
        @static
        **&#x2F;
        ctor.isPredicate = function (o) {
            return o instanceof Predicate;
        };

        &#x2F;**  
        Creates a new &#x27;simple&#x27; Predicate.  Note that this method can also take its parameters as an array.
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
        or parameters can be passed as an array.
        @example
            var predArgs = [&quot;Freight&quot;, &quot;gt&quot;, 100];
            var p1 = Predicate.create(predArgs);
        both of these are the same as 
        @example
            var p1 = new Predicate(&quot;Freight&quot;, &quot;gt&quot;, 100);
        @method create 
        @static
        @param property {String} A property name, a nested property name or an expression involving a property name.
        @param operator {FilterQueryOp|String}
        @param value {Object} - This will be treated as either a property expression or a literal depending on context.  In general, 
                 if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal. 
                 In most cases this works well, but you can also force the interpretation by setting the next parameter &#x27;valueIsLiteral&#x27; to true.
        @param [valueIsLiteral] {Boolean} - Used to force the &#x27;value&#x27; parameter to be treated as a literal - otherwise this will be inferred based on the context.
        **&#x2F;
        ctor.create = function (property, operator, value, valueIsLiteral) {
            if (Array.isArray(property)) {
                valueIsLiteral = (property.length === 4) ? property[3] : false;
                return new SimplePredicate(property[0], property[1], property[2], valueIsLiteral);
            } else {
                return new SimplePredicate(property, operator, value, valueIsLiteral);
            }
        };

        &#x2F;**  
        Creates a &#x27;composite&#x27; Predicate by &#x27;and&#x27;ing a set of specified Predicates together.
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = Predicate.and(p1, p2, p3);
        or
        @example
            var preds = [p1, p2, p3];
            var newPred = Predicate.and(preds);
        @method and
        @param predicates* {multiple Predicates|Array of Predicate}
        @static
        **&#x2F;
        ctor.and = function (predicates) {
            predicates = argsToPredicates(arguments);
            if (predicates.length === 1) {
                return predicates[0];
            } else {
                return new CompositePredicate(&quot;and&quot;, predicates);
            }
        };

        &#x2F;**  
        Creates a &#x27;composite&#x27; Predicate by &#x27;or&#x27;ing a set of specified Predicates together.
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = Predicate.or(p1, p2, p3);
        or
        @example
            var preds = [p1, p2, p3];
            var newPred = Predicate.or(preds);
        @method or
        @param predicates* {multiple Predicates|Array of Predicate}
        @static
        **&#x2F;
        ctor.or = function (predicates) {
            predicates = argsToPredicates(arguments);
            if (predicates.length === 1) {
                return predicates[0];
            } else {
                return new CompositePredicate(&quot;or&quot;, predicates);
            }
        };

        &#x2F;**  
        Creates a &#x27;composite&#x27; Predicate by &#x27;negating&#x27; a specified predicate.
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
            var not_p1 = Predicate.not(p1);
        This can also be accomplished using the &#x27;instance&#x27; version of the &#x27;not&#x27; method
        @example
            var not_p1 = p1.not();
        Both of which would be the same as
        @example
            var not_p1 = Predicate.create(&quot;Freight&quot;, &quot;le&quot;, 100);
        @method not
        @param predicate {Predicate}
        @static
        **&#x2F;
        ctor.not = function (predicate) {
            return new CompositePredicate(&quot;not&quot;, [predicate]);
        };

        &#x2F;**  
        &#x27;And&#x27;s this Predicate with one or more other Predicates and returns a new &#x27;composite&#x27; Predicate
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = p1.and(p2, p3);
        or
        @example
            var preds = [p2, p3];
            var newPred = p1.and(preds);
        The &#x27;and&#x27; method is also used to write &quot;fluent&quot; expressions
        @example
            var p4 = Predicate.create(&quot;ShipCity&quot;, &quot;startswith&quot;, &quot;F&quot;)
                .and(&quot;Size&quot;, &quot;gt&quot;, 2000);
        @method and
        @param predicates* {multiple Predicates|Array of Predicate}
        **&#x2F;
        proto.and = function (predicates) {
            predicates = argsToPredicates(arguments);
            predicates.unshift(this);
            return ctor.and(predicates);
        };

        &#x2F;**  
        &#x27;Or&#x27;s this Predicate with one or more other Predicates and returns a new &#x27;composite&#x27; Predicate
        @example
            var dt = new Date(88, 9, 12);
            var p1 = Predicate.create(&quot;OrderDate&quot;, &quot;ne&quot;, dt);
            var p2 = Predicate.create(&quot;ShipCity&quot;, &quot;startsWith&quot;, &quot;C&quot;);
            var p3 = Predicate.create(&quot;Freight&quot;, &quot;&gt;&quot;, 100);
            var newPred = p1.and(p2, p3);
        or
        @example
            var preds = [p2, p3];
            var newPred = p1.and(preds);
        The &#x27;or&#x27; method is also used to write &quot;fluent&quot; expressions
        @example
            var p4 = Predicate.create(&quot;ShipCity&quot;, &quot;startswith&quot;, &quot;F&quot;)
                .or(&quot;Size&quot;, &quot;gt&quot;, 2000);
        @method or
        @param predicates* {multiple Predicates|Array of Predicate}
        **&#x2F;
        proto.or = function (predicates) {
            predicates = argsToPredicates(arguments);
            predicates.unshift(this);
            return ctor.or(predicates);
        };

        &#x2F;**  
        Returns the &#x27;negated&#x27; version of this Predicate
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
            var not_p1 = p1.not();
        This can also be accomplished using the &#x27;static&#x27; version of the &#x27;not&#x27; method
        @example
            var p1 = Predicate.create(&quot;Freight&quot;, &quot;gt&quot;, 100);
            var not_p1 = Predicate.not(p1);
        which would be the same as
        @example
            var not_p1 = Predicate.create(&quot;Freight&quot;, &quot;le&quot;, 100);
        @method not
        **&#x2F;
        proto.not = function () {
            return new CompositePredicate(&quot;not&quot;, [this]);
        };

        &#x2F;&#x2F; methods defined in both subclasses of Predicate

        &#x2F;**  
        Returns the function that will be used to execute this Predicate against the local cache.
        @method toFunction
        @return {Function}
        **&#x2F;

        &#x2F;**  
        Returns a human readable string for this Predicate.
        @method toString
        @return {String}
        **&#x2F;

        &#x2F;**  
        Determines whether this Predicate is &#x27;valid&#x27; for the specified EntityType; This method will throw an exception
        if invalid.
        @method validate
        @param entityType {EntityType} The entityType to validate against.
        **&#x2F;

        function argsToPredicates(argsx) {
            if (argsx.length === 1 &amp;&amp; Array.isArray(argsx[0])) {
                return argsx[0];
            } else {
                var args = Array.prototype.slice.call(argsx);
                if (Predicate.isPredicate(args[0])) {
                    return args;
                } else {
                    return [Predicate.create(args)];
                }
            }
        }

        return ctor;

    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var SimplePredicate = (function () {

        var ctor = function (propertyOrExpr, operator, value, valueIsLiteral) {
            assertParam(propertyOrExpr, &quot;propertyOrExpr&quot;).isString().check();
            assertParam(operator, &quot;operator&quot;).isEnumOf(FilterQueryOp).or().isString().check();
            assertParam(value, &quot;value&quot;).isRequired(true).check();
            assertParam(valueIsLiteral).isOptional().isBoolean().check();

            this._propertyOrExpr = propertyOrExpr;
            this._fnNode1 = FnNode.create(propertyOrExpr, null);
            this._filterQueryOp = FilterQueryOp.from(operator);
            if (!this._filterQueryOp) {
                throw new Error(&quot;Unknown query operation: &quot; + operator);
            }
            this._value = value;
            this._valueIsLiteral = valueIsLiteral;
        };
        
        var proto = new Predicate({ prototype: true });
        ctor.prototype = proto;
        

        proto.toOdataFragment = function (entityType) {
            var v1Expr = this._fnNode1.toOdataFragment(entityType);
            var v2Expr;
            if (this.fnNode2 === undefined &amp;&amp; !this._valueIsLiteral) {
                this.fnNode2 = FnNode.create(this._value, entityType);
            }
            if (this.fnNode2) {
                v2Expr = this.fnNode2.toOdataFragment(entityType);
            } else {
                v2Expr = formatValue(this._value, this._fnNode1.dataType);
            }
            if (this._filterQueryOp.isFunction) {
                if (this._filterQueryOp == FilterQueryOp.Contains) {
                    return this._filterQueryOp.operator + &quot;(&quot; + v2Expr + &quot;,&quot; + v1Expr + &quot;) eq true&quot;;
                } else {
                    return this._filterQueryOp.operator + &quot;(&quot; + v1Expr + &quot;,&quot; + v2Expr + &quot;) eq true&quot;;
                }
                
            } else {
                return v1Expr + &quot; &quot; + this._filterQueryOp.operator + &quot; &quot; + v2Expr;
            }
        };

        proto.toFunction = function (entityType) {
            var dataType = this._fnNode1.dataType || DataType.fromValue(this._value);
            var predFn = getPredicateFn(entityType, this._filterQueryOp, dataType);
            var v1Fn = this._fnNode1.fn;
            if (this.fnNode2 === undefined &amp;&amp; !this._valueIsLiteral) {
                this.fnNode2 = FnNode.create(this._value, entityType);
            }
            
            if (this.fnNode2) {
                var v2Fn = this.fnNode2.fn;
                return function(entity) {
                    return predFn(v1Fn(entity), v2Fn(entity));
                };
            } else {
                var val = this._value;
                return function (entity) {
                    return predFn(v1Fn(entity), val);
                };
            }
            
        };

        proto.toString = function () {
            return core.formatString(&quot;{%1} %2 {%3}&quot;, this._propertyOrExpr, this._filterQueryOp.operator, this._value);
        };

        proto.validate = function (entityType) {
            &#x2F;&#x2F; throw if not valid
            this._fnNode1.validate(entityType);
            this.dataType = this._fnNode1.dataType;
        };
        
        &#x2F;&#x2F; internal functions

        &#x2F;&#x2F; TODO: still need to handle localQueryComparisonOptions for guids.
        
        function getPredicateFn(entityType, filterQueryOp, dataType) {
            var lqco = entityType.metadataStore.localQueryComparisonOptions;
            var mc = getComparableFn(dataType);
            var predFn;
            switch (filterQueryOp) {
                case FilterQueryOp.Equals:
                    predFn = function(v1, v2) {
                        if (v1 &amp;&amp; typeof v1 === &#x27;string&#x27;) {
                            return stringEquals(v1, v2, lqco);
                        } else {
                            return mc(v1) == mc(v2);
                        }
                    };
                    break;
                case FilterQueryOp.NotEquals:
                    predFn = function (v1, v2) {
                        if (v1 &amp;&amp; typeof v1 === &#x27;string&#x27;) {
                            return !stringEquals(v1, v2, lqco);
                        } else {
                            return mc(v1) != mc(v2);
                        }
                    };
                    break;
                case FilterQueryOp.GreaterThan:
                    predFn = function (v1, v2) { return mc(v1) &gt; mc(v2); };
                    break;
                case FilterQueryOp.GreaterThanOrEqual:
                    predFn = function (v1, v2) { return mc(v1) &gt;= mc(v2); };
                    break;
                case FilterQueryOp.LessThan:
                    predFn = function (v1, v2) { return mc(v1) &lt; mc(v2); };
                    break;
                case FilterQueryOp.LessThanOrEqual:
                    predFn = function (v1, v2) { return mc(v1) &lt;= mc(v2); };
                    break;
                case FilterQueryOp.StartsWith:
                    predFn = function (v1, v2) { return stringStartsWith(v1, v2, lqco); };
                    break;
                case FilterQueryOp.EndsWith:
                    predFn = function (v1, v2) { return stringEndsWith(v1, v2, lqco); };
                    break;
                case FilterQueryOp.Contains:
                    predFn = function (v1, v2) { return stringContains(v1, v2, lqco); };
                    break;
                default:
                    throw new Error(&quot;Unknown FilterQueryOp: &quot; + filterQueryOp);

            }
            return predFn;
        }
        
        function stringEquals(a, b, lqco) {
            if (b == null) return false;
            if (typeof b !== &#x27;string&#x27;) {
                b = b.toString();
            }
            if (lqco.usesSql92CompliantStringComparison) {
                a = (a || &quot;&quot;).trim();
                b = (b || &quot;&quot;).trim();
            }
            if (!lqco.isCaseSensitive) {
                a = (a || &quot;&quot;).toLowerCase();
                b = (b || &quot;&quot;).toLowerCase();
            }
            return a == b;
        }
        
        function stringStartsWith(a, b, lqco) {
            
            if (!lqco.isCaseSensitive) {
                a = (a || &quot;&quot;).toLowerCase();
                b = (b || &quot;&quot;).toLowerCase();
            }
            return core.stringStartsWith(a, b);
        }

        function stringEndsWith(a, b, lqco) {
            if (!lqco.isCaseSensitive) {
                a = (a || &quot;&quot;).toLowerCase();
                b = (b || &quot;&quot;).toLowerCase();
            }
            return core.stringEndsWith(a, b);
        }
        
        function stringContains(a, b, lqco) {
            if (!lqco.isCaseSensitive) {
                a = (a || &quot;&quot;).toLowerCase();
                b = (b || &quot;&quot;).toLowerCase();
            }
            return a.indexOf(b) &gt;= 0;
        }

        function formatValue(val, dataType) {
            if (val == null) {
                return null;
            }
            
            var msg;
            
            dataType = dataType || DataType.fromValue(val);
                       
            if (dataType.isNumeric) {
                if (typeof val === &quot;string&quot;) {
                    if (dataType.isInteger) {
                        val = parseInt(val);
                    } else {
                        val = parseFloat(val);
                    }
                }
                return val;
            } else if (dataType === DataType.String) {
                return &quot;&#x27;&quot; + val + &quot;&#x27;&quot;;
            } else if (dataType === DataType.DateTime) {
                try {
                    return &quot;datetime&#x27;&quot; + val.toISOString() + &quot;&#x27;&quot;;
                } catch(e) {
                    msg = core.formatString(&quot;&#x27;%1&#x27; is not a valid dateTime&quot;, val);
                    throw new Error(msg);
                }
            } else if (dataType == DataType.Time) {
                if (!core.isDuration(val)) {
                    msg = core.formatString(&quot;&#x27;%1&#x27; is not a valid ISO 8601 duration&quot;, val);
                    throw new Error(msg);
                }
                return &quot;time&#x27;&quot; + val + &quot;&#x27;&quot;;
            } else if (dataType === DataType.Guid) {
                if (!core.isGuid(val)) {
                    msg = core.formatString(&quot;&#x27;%1&#x27; is not a valid guid&quot;, val);
                    throw new Error(msg);
                }
                return &quot;guid&#x27;&quot; + val + &quot;&#x27;&quot;;
            } else if (dataType === DataType.Boolean) {
                if (typeof val === &quot;string&quot;) {
                    return val.trim().toLowerCase() === &quot;true&quot;;
                } else {
                    return val;
                }
            } else {
                return val;
            }

        }

        return ctor;

    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var CompositePredicate = (function () {

        var ctor = function (booleanOperator, predicates) {
            &#x2F;&#x2F; if debug
            if (!Array.isArray(predicates)) {
                throw new Error(&quot;predicates parameter must be an array&quot;);
            }
            &#x2F;&#x2F; end debug
            if ((this.symbol === &quot;not&quot;) &amp;&amp; (predicates.length !== 1)) {
                throw new Error(&quot;Only a single predicate can be passed in with the &#x27;Not&#x27; operator&quot;);
            }

            this._booleanQueryOp = BooleanQueryOp.from(booleanOperator);
            if (!this._booleanQueryOp) {
                throw new Error(&quot;Unknown query operation: &quot; + booleanOperator);
            }
            this._predicates = predicates;
        };
        var proto  = new Predicate({ prototype: true });
        ctor.prototype = proto;

        proto.toOdataFragment = function (entityType) {
            if (this._predicates.length == 1) {
                return this._booleanQueryOp.operator + &quot; &quot; + &quot;(&quot; + this._predicates[0].toOdataFragment(entityType) + &quot;)&quot;;
            } else {
                var result = this._predicates.map(function (p) {
                    return &quot;(&quot; + p.toOdataFragment(entityType) + &quot;)&quot;;
                }).join(&quot; &quot; + this._booleanQueryOp.operator + &quot; &quot;);
                return result;
            }
        };

        proto.toFunction = function (entityType) {
            return createFunction(entityType, this._booleanQueryOp, this._predicates);
        };

        proto.toString = function () {
            if (this._predicates.length == 1) {
                return this._booleanQueryOp.operator + &quot; &quot; + &quot;(&quot; + this._predicates[0] + &quot;)&quot;;
            } else {
                var result = this._predicates.map(function (p) {
                    return &quot;(&quot; + p.toString() + &quot;)&quot;;
                }).join(&quot; &quot; + this._booleanQueryOp.operator + &quot; &quot;);
                return result;
            }
        };

        proto.validate = function (entityType) {
            &#x2F;&#x2F; will throw if not found;
            if (this._isValidated) return;
            this._predicates.every(function (p) {
                p.validate(entityType);
            });
            this._isValidated = true;
        };

        function createFunction(entityType, booleanQueryOp, predicates) {
            var func, funcs;
            switch (booleanQueryOp) {
                case BooleanQueryOp.Not:
                    func = predicates[0].toFunction(entityType);
                    return function (entity) {
                        return !func(entity);
                    };
                case BooleanQueryOp.And:
                    funcs = predicates.map(function (p) { return p.toFunction(entityType); });
                    return function (entity) {
                        var result = funcs.reduce(function (prev, cur) {
                            return prev &amp;&amp; cur(entity);
                        }, true);
                        return result;
                    };
                case BooleanQueryOp.Or:
                    funcs = predicates.map(function (p) { return p.toFunction(entityType); });
                    return function (entity) {
                        var result = funcs.reduce(function (prev, cur) {
                            return prev || cur(entity);
                        }, false);
                        return result;
                    };
                default:
                    throw new Error(&quot;Invalid boolean operator:&quot; + booleanQueryOp);
            }
        }

        return ctor;
    })();

    &#x2F;&#x2F; Not exposed externally for now
    var OrderByClause = (function () {
        &#x2F;*
        An OrderByClause is a description of the properties and direction that the result 
        of a query should be sorted in.  OrderByClauses are immutable, which means that any
        method that would modify an OrderByClause actually returns a new OrderByClause. 

        For example for an Employee object with properties of &#x27;Company&#x27; and &#x27;LastName&#x27; the following would be valid expressions:

            var obc = new OrderByClause(&quot;Company.CompanyName, LastName&quot;) 
                or 
            var obc = new OrderByClause(&quot;Company.CompanyName desc, LastName&quot;) 
                or 
            var obc = new OrderByClause(&quot;Company.CompanyName, LastName&quot;, true);
        @class OrderByClause
        *&#x2F;
        
        &#x2F;*
        @method &lt;ctor&gt; OrderByClause
        @param propertyPaths {String|Array or String} A &#x27;,&#x27; delimited string of &#x27;propertyPaths&#x27; or an array of property path string. Each &#x27;propertyPath&#x27;
        should be a valid property name or property path for the EntityType of the query associated with this clause. 
        @param [isDesc=false] {Boolean}
        *&#x2F;
        var ctor = function (propertyPaths, isDesc) {
            if (propertyPaths.prototype === true) {
                &#x2F;&#x2F; used to construct prototype
                return this;
            }
            return ctor.create(propertyPaths, isDesc);
        };
        var proto = ctor.prototype;

        &#x2F;*
        Alternative method of creating an OrderByClause. 
        Example for an Employee object with properties of &#x27;Company&#x27; and &#x27;LastName&#x27;: 

            var obc = OrderByClause.create(&quot;Company.CompanyName, LastName&quot;) 
                or 
            var obc = OrderByClause.create(&quot;Company.CompanyName desc, LastName&quot;) 
                or 
            var obc = OrderByClause.create(&quot;Company.CompanyName, LastName&quot;, true);
        @method create 
        @static
        @param propertyPaths {Array of String} An array of &#x27;propertyPaths&#x27;. Each &#x27;propertyPaths&#x27; 
        parameter should be a valid property name or property path for the EntityType of the query associated with this clause. 
        @param [isDesc=false] {Boolean}
        *&#x2F;
        ctor.create = function (propertyPaths, isDesc) {
            if (propertyPaths.length &gt; 1) {
                var clauses = propertyPaths.map(function (pp) {
                    return new SimpleOrderByClause(pp, isDesc);
                });
                return new CompositeOrderByClause(clauses);
            } else {
                return new SimpleOrderByClause(propertyPaths[0], isDesc);
            }
        };

        &#x2F;*
        Returns a &#x27;composite&#x27; OrderByClause by combining other OrderByClauses.
        @method combine
        @static
        @param orderByClauses {Array of OrderByClause}
        *&#x2F;
        ctor.combine = function (orderByClauses) {
            return new CompositeOrderByClause(orderByClauses);
        };

        &#x2F;*
        Returns whether an object is an OrderByClause.
        @method isOrderByClause
        @static
        @param obj {Object}
        *&#x2F;
        ctor.isOrderByClause = function (obj) {
            return obj instanceof OrderByClause;
        };

        &#x2F;*
        Returns whether a new OrderByClause with a specified clause add to the end of this one. 
        @method addClause
        @param orderByClause {OrderByClause}
        *&#x2F;
        proto.addClause = function (orderByClause) {
            return new CompositeOrderByClause([this, orderByClause]);
        };

        return ctor;
    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var SimpleOrderByClause = (function () {

        var ctor = function (propertyPath, isDesc) {
            if (!(typeof propertyPath == &#x27;string&#x27;)) {
                throw new Error(&quot;propertyPath is not a string&quot;);
            }
            propertyPath = propertyPath.trim();

            var parts = propertyPath.split(&#x27; &#x27;);
            &#x2F;&#x2F; parts[0] is the propertyPath; [1] would be whether descending or not.
            if (parts.length &gt; 1 &amp;&amp; isDesc !== true &amp;&amp; isDesc !== false) {
                isDesc = core.stringStartsWith(parts[1].toLowerCase(), &quot;desc&quot;);
                if (!isDesc) {
                    &#x2F;&#x2F; isDesc is false but check to make sure its intended.
                    var isAsc = core.stringStartsWith(parts[1].toLowerCase(), &quot;asc&quot;);
                    if (!isAsc) {
                        throw new Error(&quot;the second word in the propertyPath must begin with &#x27;desc&#x27; or &#x27;asc&#x27;&quot;);
                    }
                    
                }
            }
            this.propertyPath = parts[0];
            this.isDesc = isDesc;
        };
        var proto = new OrderByClause({ prototype: true });
        ctor.prototype = proto;

        proto.validate = function (entityType) {
            if (!entityType) {
                return;
            } &#x2F;&#x2F; can&#x27;t validate yet
            &#x2F;&#x2F; will throw an exception on bad propertyPath
            this.lastProperty = entityType.getProperty(this.propertyPath, true);
        };

        proto.toOdataFragment = function (entityType) {
            return entityType._clientPropertyPathToServer(this.propertyPath) + (this.isDesc ? &quot; desc&quot; : &quot;&quot;);
        };

        proto.getComparer = function () {
            var propertyPath = this.propertyPath;
            var isDesc = this.isDesc;
            var that = this;
            
            return function (entity1, entity2) {
                var value1 = getPropertyPathValue(entity1, propertyPath);
                var value2 = getPropertyPathValue(entity2, propertyPath);
                var dataType = (that.lastProperty || {}).dataType;
                if (dataType === DataType.String) {
                    if (!that.lastProperty.parentType.metadataStore.localQueryComparisonOptions.isCaseSensitive) {
                        value1 = (value1 || &quot;&quot;).toLowerCase();
                        value2 = (value2 || &quot;&quot;).toLowerCase();
                    }
                } else {
                    var normalize = getComparableFn(dataType);
                    value1 = normalize(value1);
                    value2 = normalize(value2);
                }
                if (value1 == value2) {
                    return 0;
                } else if (value1 &gt; value2) {
                    return isDesc ? -1 : 1;
                } else {
                    return isDesc ? 1 : -1;
                }
            };
        };


        return ctor;
    })();

    &#x2F;&#x2F; Does not need to be exposed.
    var CompositeOrderByClause = (function () {
        var ctor = function (orderByClauses) {
            var resultClauses = [];
            orderByClauses.forEach(function (obc) {
                if (obc instanceof CompositeOrderByClause) {
                    resultClauses = resultClauses.concat(obc.orderByClauses);
                } else if (obc instanceof SimpleOrderByClause) {
                    resultClauses.push(obc);
                } else {
                    throw new Error(&quot;Invalid argument to CompositeOrderByClause ctor.&quot;);
                }
            });
            this._orderByClauses = resultClauses;

        };
        var proto = new OrderByClause({ prototype: true });
        ctor.prototype = proto;


        proto.validate = function (entityType) {
            this._orderByClauses.forEach(function (obc) {
                obc.validate(entityType);
            });
        };

        proto.toOdataFragment = function (entityType) {
            var strings = this._orderByClauses.map(function (obc) {
                return obc.toOdataFragment(entityType);
            });
            &#x2F;&#x2F; should return something like CompanyName,Address&#x2F;City desc
            return strings.join(&#x27;,&#x27;);
        };

        proto.getComparer = function () {
            var orderByFuncs = this._orderByClauses.map(function (obc) {
                return obc.getComparer();
            });
            return function (entity1, entity2) {
                for (var i = 0; i &lt; orderByFuncs.length; i++) {
                    var result = orderByFuncs[i](entity1, entity2);
                    if (result != 0) {
                        return result;
                    }
                }
                return 0;
            };
        };
        return ctor;
    })();
    
    &#x2F;&#x2F; Not exposed
    var SelectClause = (function () {
        
        var ctor = function (propertyPaths) {
            this.propertyPaths = propertyPaths;
            this._pathNames = propertyPaths.map(function(pp) {
                return pp.replace(&quot;.&quot;, &quot;_&quot;);
            });
        };
        var proto = ctor.prototype;

        proto.validate = function (entityType) {
            if (!entityType) {
                return;
            } &#x2F;&#x2F; can&#x27;t validate yet
            &#x2F;&#x2F; will throw an exception on bad propertyPath
            this.propertyPaths.forEach(function(path) {
                entityType.getProperty(path, true);
            });
        };

        proto.toOdataFragment = function(entityType) {
            var frag = this.propertyPaths.map(function (pp) {
                 return entityType._clientPropertyPathToServer(pp);
             }).join(&quot;,&quot;);
             return frag;
        };
        
        proto.toFunction = function (entityType) {
            var that = this;
            return function (entity) {
                var result = {};
                that.propertyPaths.forEach(function (path, i) {
                    result[that._pathNames[i]] = getPropertyPathValue(entity, path);
                });
                return result;
            };
        };

        return ctor;
    })();
    
     &#x2F;&#x2F; Not exposed
    var ExpandClause = (function () {
        
        &#x2F;&#x2F; propertyPaths is an array of strings.
        var ctor = function (propertyPaths) {
            this.propertyPaths = propertyPaths;
        };
        
        var proto = ctor.prototype;
       
&#x2F;&#x2F;        &#x2F;&#x2F; TODO:
&#x2F;&#x2F;        proto.validate = function (entityType) {
&#x2F;&#x2F;            
&#x2F;&#x2F;        };

        proto.toOdataFragment = function(entityType) {
            var frag = this.propertyPaths.map(function(pp) {
                return entityType._clientPropertyPathToServer(pp);
            }).join(&quot;,&quot;);
            return frag;
        };

        return ctor;
    })();
    

    &#x2F;&#x2F; propertyPath can be either an array of paths or a &#x27;.&#x27; delimited string.
    
    function createPropFunction(propertyPath) {
        var properties = propertyPath.split(&#x27;.&#x27;);
        if (properties.length === 1) {
            return function(entity) {
                return entity.getProperty(propertyPath);
            };
        } else {
            return function(entity) {
                return getPropertyPathValue(entity, properties);
            };
        }
    }

    function getPropertyPathValue(obj, propertyPath) {
        var properties;
        if (Array.isArray(propertyPath)) {
            properties = propertyPath;
        } else {
            properties = propertyPath.split(&quot;.&quot;);
        }
        if (properties.length === 1) {
            return obj.getProperty(propertyPath);
        } else {
            var nextValue = obj;
            for (var i = 0; i &lt; properties.length; i++) {
                nextValue = nextValue.getProperty(properties[i]);
                &#x2F;&#x2F; == in next line is deliberate - checks for undefined or null.
                if (nextValue == null) {
                    break;
                }
            }
            return nextValue;
        }
    }
   
    function getComparableFn(dataType) {
        if (dataType === DataType.DateTime) {
            &#x2F;&#x2F; dates don&#x27;t perform equality comparisons properly 
            return function (value) { return value &amp;&amp; value.getTime(); };
        } else if (dataType === DataType.Time) {
            &#x2F;&#x2F; durations must be converted to compare them
            return function(value) { return value &amp;&amp; core.durationToSeconds(value); };
        } else {
            return function(value) { return value; };
        }
        
    }

    &#x2F;&#x2F; Fixup --- because EntityAspect does not have access to EntityQuery or EntityMetadata

    EntityAspect.prototype.loadNavigationProperty = function (navigationProperty, callback, errorCallback) {
        var entity = this.entity;
        var navProperty = entity.entityType._checkNavProperty(navigationProperty);
        var query = EntityQuery.fromEntityNavigation(entity, navProperty, callback, errorCallback);
        return entity.entityAspect.entityManager.executeQuery(query, callback, errorCallback);
    };

    &#x2F;&#x2F; expose
    &#x2F;&#x2F; do not expose SimplePredicate and CompositePredicate 
    &#x2F;&#x2F; Note: FnNode only exposed for testing purposes
    return {
        FilterQueryOp: FilterQueryOp,
        Predicate: Predicate,
        EntityQuery: EntityQuery,
        FnNode: FnNode,
        &#x2F;&#x2F; Not documented - only exposed for testing purposes
        OrderByClause: OrderByClause
    };
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="primary-nav-foot">
	<ul>
		<li>
			<a href="http://www.breezejs.com/documentation/download" target="_blank">Download</a></li>
		<li>
			<a href="http://learn.breezejs.com/" target="_blank">Tutorials</a></li>	
		<li>
			<a href="http://www.breezejs.com/documentation/introduction">Docs</a></li>
		<li>
			<a href="http://www.breezejs.com/samples">Samples</a></li>
		<li>
			<a href="http://www.breezejs.com/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://stackoverflow.com/questions/tagged/breeze?sort=newest" target="_blank">Forum</a></li>
		<li>
			<a href="http://www.breezejs.com/support" target="_blank">Support</a></li>
	</ul>
</div>
</div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
