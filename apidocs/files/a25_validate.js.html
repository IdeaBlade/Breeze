<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>a25_validate.js - The Breeze API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
<!-- commenting out until beta goes live	<link rel="stylesheet" href="http://breezejs.com/sites/all/themes/omega/alpha/css/apha-reset.css"> 
-->    
	<link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
	<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34729465-1']);
  _gaq.push(['_setDomainName', 'breezejs.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body class="yui3-skin-sam">
<script type="text/javascript">
  var uvOptions = {};
  (function() {
    var uv = document.createElement('script'); uv.type = 'text/javascript'; uv.async = true;
    uv.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'widget.uservoice.com/GHug452CgVREu58xjoDg.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(uv, s);
  })();
</script>
<div id="wrap">

<div id="doc">
<div class="header">
<div class="logo">
	<a href="http://www.breezejs.com/home"><img src="http://www.breezejs.com/sites/all/themes/breeze/images/breeze_large.png" /></a>
	</div>

    <div class="primary-nav">
<ul>
		
		<li>
			<a href="http://www.breezejs.com/documentation/download" target="_blank">Download</a></li>
		<li>
			<a href="http://learn.breezejs.com/" target="_blank">Tutorials</a></li>	
		<li>
			<a href="http://www.breezejs.com/documentation/introduction">Docs</a></li>
		<li>
			<a href="http://www.breezejs.com/samples">Samples</a></li>
		<li>
			<a href="http://www.breezejs.com/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.breezejs.com/support" target="_blank">Support</a></li>
		<li>
			<a href="http://www.breezejs.com/blog" target="_blank">Blog</a></li>				
		
	</ul>
</div>
</div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AutoGeneratedKeyType.html">AutoGeneratedKeyType</a></li>
            
                <li><a href="..&#x2F;classes/ComplexAspect.html">ComplexAspect</a></li>
            
                <li><a href="..&#x2F;classes/ComplexType.html">ComplexType</a></li>
            
                <li><a href="..&#x2F;classes/config.html">config</a></li>
            
                <li><a href="..&#x2F;classes/DataProperty.html">DataProperty</a></li>
            
                <li><a href="..&#x2F;classes/DataService.html">DataService</a></li>
            
                <li><a href="..&#x2F;classes/DataType.html">DataType</a></li>
            
                <li><a href="..&#x2F;classes/EntityAction.html">EntityAction</a></li>
            
                <li><a href="..&#x2F;classes/EntityAspect.html">EntityAspect</a></li>
            
                <li><a href="..&#x2F;classes/EntityKey.html">EntityKey</a></li>
            
                <li><a href="..&#x2F;classes/EntityManager.html">EntityManager</a></li>
            
                <li><a href="..&#x2F;classes/EntityQuery.html">EntityQuery</a></li>
            
                <li><a href="..&#x2F;classes/EntityState.html">EntityState</a></li>
            
                <li><a href="..&#x2F;classes/EntityType.html">EntityType</a></li>
            
                <li><a href="..&#x2F;classes/Enum.html">Enum</a></li>
            
                <li><a href="..&#x2F;classes/EnumSymbol.html">EnumSymbol</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/FetchStrategy.html">FetchStrategy</a></li>
            
                <li><a href="..&#x2F;classes/FilterQueryOp.html">FilterQueryOp</a></li>
            
                <li><a href="..&#x2F;classes/JsonResultsAdapter.html">JsonResultsAdapter</a></li>
            
                <li><a href="..&#x2F;classes/LocalQueryComparisonOptions.html">LocalQueryComparisonOptions</a></li>
            
                <li><a href="..&#x2F;classes/MergeStrategy.html">MergeStrategy</a></li>
            
                <li><a href="..&#x2F;classes/MetadataStore.html">MetadataStore</a></li>
            
                <li><a href="..&#x2F;classes/NamingConvention.html">NamingConvention</a></li>
            
                <li><a href="..&#x2F;classes/NavigationProperty.html">NavigationProperty</a></li>
            
                <li><a href="..&#x2F;classes/Predicate.html">Predicate</a></li>
            
                <li><a href="..&#x2F;classes/Promise.html">Promise</a></li>
            
                <li><a href="..&#x2F;classes/QueryOptions.html">QueryOptions</a></li>
            
                <li><a href="..&#x2F;classes/SaveOptions.html">SaveOptions</a></li>
            
                <li><a href="..&#x2F;classes/ValidationError.html">ValidationError</a></li>
            
                <li><a href="..&#x2F;classes/ValidationOptions.html">ValidationOptions</a></li>
            
                <li><a href="..&#x2F;classes/Validator.html">Validator</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_complexArray_.html">ↈ_complexArray_</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_keyGenerator_interface.html">ↈ_keyGenerator_interface</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_primitiveArray_.html">ↈ_primitiveArray_</a></li>
            
                <li><a href="..&#x2F;classes/ↈ_relationArray_.html">ↈ_relationArray_</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/breeze.html">breeze</a></li>
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: a25_validate.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
﻿&#x2F;**
@module breeze
**&#x2F;

var Validator = (function () {

    var INT16_MIN = -32768;
    var INT16_MAX = 32767;

    var INT32_MIN = -2147483648;
    var INT32_MAX = 2147483647;

    var BYTE_MIN = 0;
    var BYTE_MAX = 255;

    &#x2F;&#x2F; add common props and methods for every validator &#x27;context&#x27; here.
    var rootContext = {
        displayName: function (context) {
            if (context.property) {
                return context.property.displayName || context.propertyName || context.property.name;
            } else {
                return &quot;Value&quot;;
            }
        }
    };

    &#x2F;**
    Instances of the Validator class provide the logic to validate another object and provide a description of any errors
    encountered during the validation process.  They are typically associated with a &#x27;validators&#x27; property on the following types: {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}}, 
    {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}} or {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}}.
        
    A number of property level validators are registered automatically, i.e added to each DataProperty.validators property 
    based on {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}} metadata.  For example, 
        
    - DataProperty.dataType -&gt; one of the &#x27;dataType&#x27; validator methods such as Validator.int64, Validator.date, Validator.bool etc.
    - DataProperty.maxLength -&gt; Validator.maxLength 
    - DataProperty.isNullable -&gt; Validator.required (if not nullable)

    @class Validator
    **&#x2F;
        
    &#x2F;**
    Validator constructor - This method is used to create create custom validations.  Several
    basic &quot;Validator&quot; construction methods are also provided as static methods to this class. These methods
    provide a simpler syntax for creating basic validations.
   
    Many of these stock validators are inspired by and implemented to conform to the validators defined at
    http:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;system.componentmodel.dataannotations.aspx

    Sometimes a custom validator will be required.
    @example
    Most validators will be &#x27;property&#x27; level validators, like this.
    @example
        &#x2F;&#x2F; v is this function is the value to be validated, in this case a &quot;country&quot; string.
        var valFn = function (v) {
            if (v == null) return true;
            return (core.stringStartsWith(v, &quot;US&quot;));
        };
        var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, { 
            displayName: &quot;Country&quot;, 
            messageTemplate: &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot; 
        });

        &#x2F;&#x2F; Now plug it into Breeze.
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = metadataStore.getEntityType(&quot;Customer&quot;);
        var countryProp = custType.getProperty(&quot;Country&quot;);
        &#x2F;&#x2F; Note that validator is added to a &#x27;DataProperty&#x27; validators collection.
        prop.validators.push(countryValidator);
    Entity level validators are also possible
    @example
        function isValidZipCode(value) {
            var re = &#x2F;^\d{5}([\-]\d{4})?$&#x2F;;
            return (re.test(value));
        }               
           
        &#x2F;&#x2F; v in this case will be a Customer entity
        var valFn = function (v) {
            &#x2F;&#x2F; This validator only validates US Zip Codes.
            if ( v.getProperty(&quot;Country&quot;) === &quot;USA&quot;) {
                var postalCode = v.getProperty(&quot;PostalCode&quot;);
                return isValidZipCode(postalCode);
            }
            return true;
        };
        var zipCodeValidator = new Validator(&quot;zipCodeValidator&quot;, valFn, 
            { messageTemplate: &quot;For the US, this is not a valid PostalCode&quot; });
        
        &#x2F;&#x2F; Now plug it into Breeze.
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        &#x2F;&#x2F; Note that validator is added to an &#x27;EntityType&#x27; validators collection.
        custType.validators.push(zipCodeValidator);
    What is commonly needed is a way of creating a parameterized function that will itself
    return a new Validator.  This requires the use of a &#x27;context&#x27; object.
    @example
        &#x2F;&#x2F; create a function that will take in a config object
        &#x2F;&#x2F; and will return a validator
        var numericRangeValidator = function(context) {
            var valFn = function(v, ctx) {
                if (v == null) return true;
                if (typeof(v) !== &quot;number&quot;) return false;
                if (ctx.min != null &amp;&amp; v &lt; ctx.min) return false;
                if (ctx.max != null &amp;&amp; v &gt; ctx.max) return false;
                return true;
            };
            &#x2F;&#x2F; The last parameter below is the &#x27;context&#x27; object that will be passed into the &#x27;ctx&#x27; parameter above
            &#x2F;&#x2F; when this validator executes. Several other properties, such as displayName will get added to this object as well.
            return new Validator(&quot;numericRange&quot;, valFn, {
                messageTemplate: &quot;&#x27;%displayName%&#x27; must be an integer between the values of %min% and %max%&quot;,
                min: context.min,
                max: context.max
            });
        };
        &#x2F;&#x2F; Assume that freightProperty is a DataEntityProperty that describes numeric values.
        &#x2F;&#x2F; register the validator
        freightProperty.validators.push(numericRangeValidator({ min: 100, max: 500 }));

    @method &lt;ctor&gt; Validator
    @param name {String} The name of this validator.
    @param validatorFn {Function} A function to perform validation.
            
    validatorFn(value, context)
    @param validatorFn.value {Object} Value to be validated
    @param validatorFn.context {Object} The same context object passed into the constructor with the following additional properties if not
    otherwise specified.
    @param validatorFn.context.value {Object} The value being validated.
    @param validatorFn.context.name {String} The name of the validator being executed.
    @param validatorFn.context.displayName {String} This will be either the value of the property&#x27;s &#x27;displayName&#x27; property or
    the value of its &#x27;name&#x27; property or the string &#x27;Value&#x27;
    @param validatorFn.context.messageTemplate {String} This will either be the value of Validator.messageTemplates[ {this validators name}] or null. Validator.messageTemplates
    is an object that is keyed by validator name and that can be added to in order to &#x27;register&#x27; your own message for a given validator. 
    The following property can also be specified for any validator to force a specific errorMessage string
    @param [validatorFn.context.message] {String} If this property is set it will be used instead of the &#x27;messageTemplate&#x27; property when an
    error message is generated. 
                    
    @param [context] {Object} A free form object whose properties will made available during the validation and error message creation process.
    This object will be passed into the Validator&#x27;s validation function whenever &#x27;validate&#x27; is called. See above for a description
    of additional properties that will be automatically added to this object if not otherwise specified. 
    **&#x2F;
    var ctor = function (name, valFn, context) {
        &#x2F;&#x2F; _baseContext is what will get serialized 
        this._baseContext = context || {};
        this._baseContext.name = name;
        context = __extend(Object.create(rootContext), this._baseContext);
        context.messageTemplate = context.messageTemplate || ctor.messageTemplates[name];
        this.name = name;
        this.valFn = valFn;
        this.context = context;
    };
    var proto = ctor.prototype;
    proto._$typeName = &quot;Validator&quot;;
    
    &#x2F;**
    The name of this validator.

    __readOnly__
    @property name {String}
    **&#x2F;

    &#x2F;**
    The context for this validator.
        
    This object will typically contain at a minimum the following properties. &quot;name&quot;, &quot;displayName&quot;, and &quot;message&quot; or &quot;messageTemplate&quot;.
    __readOnly__
    @property context {Object}
    **&#x2F;


    &#x2F;**
    Run this validator against the specified value.  This method will usually be called internally either
    automatically by an property change, entity attach, query or save operation, or manually as a result of
    a validateEntity call on the EntityAspect. The resulting ValidationResults are available via the 
    EntityAspect.getValidationErrors method.

    However, you can also call a validator directly either for testing purposes or some other reason if needed.
    @example
        &#x2F;&#x2F; using one of the predefined validators
        var validator = Validator.maxLength({ maxLength: 5, displayName: &quot;City&quot; });
        &#x2F;&#x2F; should be ok because &quot;asdf&quot;.length &lt; 5
        var result = validator.validate(&quot;asdf&quot;);
        ok(result === null);
        result = validator.validate(&quot;adasdfasdf&quot;);
        &#x2F;&#x2F; extract all of the properties of the &#x27;result&#x27;
        var errMsg = result.errorMessage;
        var context = result.context;
        var sameValidator = result.validator;
    @method validate
    @param value {Object} Value to validate
    @param additionalContext {Object} Any additional contextual information that the Validator
    can make use of.
    @return {ValidationError|null} A ValidationError if validation fails, null otherwise
    **&#x2F;
    proto.validate = function (value, additionalContext) {
        var currentContext;
        if (additionalContext) {
            currentContext = __extend(Object.create(this.context), additionalContext);
        } else {
            currentContext = this.context;
        }
        this.currentContext = currentContext;
        
        try {
            if (this.valFn(value, currentContext)) {
                return null;
            } else {
                currentContext.value = value;
                return new ValidationError(this, currentContext, this.getMessage());
            }
        } catch (e) {
            return new ValidationError(this, currentContext, &quot;Exception occured while executing this validator: &quot; + this.name);
        }
    };

        
    &#x2F;&#x2F; context.value is not avail unless validate was called first.

    &#x2F;**
    Returns the message generated by the most recent execution of this Validator.
    @example
        var v0 = Validator.maxLength({ maxLength: 5, displayName: &quot;City&quot; });
        v0.validate(&quot;adasdfasdf&quot;);
        var errMessage = v0.getMessage());
    @method getMessage
    @return {String}
    **&#x2F;
    proto.getMessage = function () {
        try {
            var context = this.currentContext;
            var message = context.message;
            if (message) {
                if (typeof (message) === &quot;function&quot;) {
                    return message(context);
                } else {
                    return message;
                }
            } else if (context.messageTemplate) {
                return formatTemplate(context.messageTemplate, context);
            } else {
                return &quot;invalid value: &quot; + this.name || &quot;{unnamed validator}&quot;;
            }
        } catch (e) {
            return &quot;Unable to format error message&quot; + e.toString();
        }
    };

    proto.toJSON = function () {
        return this._baseContext;
    };

    ctor.fromJSON = function (json) {
        var validatorName = &quot;Validator.&quot; + json.name;
        var fn = __config.functionRegistry[validatorName];
        if (!fn) {
            throw new Error(&quot;Unable to locate a validator named:&quot; + json.name);
        }
        return fn(json);
    };

    &#x2F;**
    Register a validator instance so that any deserialized metadata can reference it. 
    @method register
    @static
    @param validator {Validator} Validator to register.
    **&#x2F;
    ctor.register = function(validator) {
        __config.registerFunction(function () { return validator; }, &quot;Validator.&quot; + validator.name);
    };

    &#x2F;**
    Register a validator factory so that any deserialized metadata can reference it. 
    @method registerFactory
    @static
    @param validatorFactory {Function} A function that optionally takes a context property and returns a Validator instance.
    @param name {String} The name of the validator.
    **&#x2F;
    ctor.registerFactory = function(validatorFn, name) {
        __config.registerFunction(validatorFn, &quot;Validator.&quot; + name);
    };

    &#x2F;**
    Map of standard error message templates keyed by validator name.
    You can add to or modify this object to customize the template used for any validation error message.
    @example
        &#x2F;&#x2F; v is this function is the value to be validated, in this case a &quot;country&quot; string.
        var valFn = function (v) {
            if (v == null) return true;
            return (core.stringStartsWith(v, &quot;US&quot;));
        };
        var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, { displayName: &quot;Country&quot; }); 
        Validator.messageTemplates[&quot;countryIsUS&quot;, &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot;);
    This will have a similar effect to this
            var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, { 
            displayName: &quot;Country&quot;, 
            messageTemplate: &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot; 
        });
    @property messageTemplates {Object}
    @static
    **&#x2F;
    ctor.messageTemplates = {
        bool: &quot;&#x27;%displayName%&#x27; must be a &#x27;true&#x27; or &#x27;false&#x27; value&quot;,
        creditCard: &quot;The %displayName% is not a valid credit card number&quot;,
        date: &quot;&#x27;%displayName%&#x27; must be a date&quot;,
        duration: &quot;&#x27;%displayName%&#x27; must be a ISO8601 duration string, such as &#x27;P3H24M60S&#x27;&quot;,
        emailAddress: &quot;The %displayName% &#x27;%value%&#x27; is not a valid email address&quot;,
        guid: &quot;&#x27;%displayName%&#x27; must be a GUID&quot;,
        integer: &quot;&#x27;%displayName%&#x27; must be an integer&quot;,
        integerRange: &quot;&#x27;%displayName%&#x27; must be an integer between the values of %minValue% and %maxValue%&quot;,
        maxLength: &quot;&#x27;%displayName%&#x27; must be a string with less than %maxLength% characters&quot;,
        number: &quot;&#x27;%displayName%&#x27; must be a number&quot;,
        phone: &quot;The %displayName% &#x27;%value%&#x27; is not a valid phone number&quot;,
        regularExpression: &quot;The %displayName% &#x27;%value%&#x27; does not match &#x27;%expression%&#x27;&quot;,
        required: &quot;&#x27;%displayName%&#x27; is required&quot;,
        string: &quot;&#x27;%displayName%&#x27; must be a string&quot;,
        stringLength: &quot;&#x27;%displayName%&#x27; must be a string with between %minLength% and %maxLength% characters&quot;,
        url: &quot;The %displayName% &#x27;%value%&#x27; is not a valid url&quot;
    };

    &#x2F;**
    Returns a standard &#x27;required value&#x27; Validator
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var regionProperty - custType.getProperty(&quot;Region&quot;);
        &#x2F;&#x2F; Makes &quot;Region&quot; on Customer a required property.
        regionProperty.validators.push(Validator.required());
    @method required
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.required = function () {
        var valFn = function (v, ctx) {
            if (typeof v === &quot;string&quot;) {
                if (ctx &amp;&amp; ctx.allowEmptyStrings) return true;
                return v.length &gt; 0;
            } else {
                return v != null;
            }
        };
        return new ctor(&quot;required&quot;, valFn);
    };

    &#x2F;**
    Returns a standard maximum string length Validator; the maximum length must be specified
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var regionProperty - custType.getProperty(&quot;Region&quot;);
        &#x2F;&#x2F; Validates that the value of the Region property on Customer will be less than or equal to 5 characters.
        regionProperty.validators.push(Validator.maxLength( {maxLength: 5}));
    @method maxLength
    @static
    @param context {Object} 
    @param context.maxLength {Integer}
    @return {Validator} A new Validator
    **&#x2F;
    ctor.maxLength = function (context) {
        var valFn = function (v, ctx) {
            if (v == null) return true;
            if (typeof (v) !== &quot;string&quot;) return false;
            return v.length &lt;= ctx.maxLength;
        };
        return new ctor(&quot;maxLength&quot;, valFn, context);
    };

    &#x2F;**
    Returns a standard string length Validator; both minimum and maximum lengths must be specified.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var regionProperty - custType.getProperty(&quot;Region&quot;);
        &#x2F;&#x2F; Validates that the value of the Region property on Customer will be 
        &#x2F;&#x2F; between 2 and 5 characters
        regionProperty.validators.push(Validator.stringLength( {minLength: 2, maxLength: 5});
    @method stringLength
    @static
    @param context {Object} 
    @param context.maxLength {Integer}
    @param context.minLength {Integer}
    @return {Validator} A new Validator
    **&#x2F;
    ctor.stringLength = function (context) {
        var valFn = function (v, ctx) {
            if (v == null) return true;
            if (typeof (v) !== &quot;string&quot;) return false;
            if (ctx.minLength != null &amp;&amp; v.length &lt; ctx.minLength) return false;
            if (ctx.maxLength != null &amp;&amp; v.length &gt; ctx.maxLength) return false;
            return true;
        };
        return new ctor(&quot;stringLength&quot;, valFn, context);
    };

    &#x2F;**
    Returns a standard string dataType Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var regionProperty - custType.getProperty(&quot;Region&quot;);
        &#x2F;&#x2F; Validates that the value of the Region property on Customer is a string.
        regionProperty.validators.push(Validator.string());
    @method string
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.string = function () {
        var valFn = function (v) {
            if (v == null) return true;
            return (typeof v === &quot;string&quot;);
        };
        return new ctor(&quot;string&quot;, valFn );
    };

    &#x2F;**
    Returns a Guid data type Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
        var customerIdProperty - custType.getProperty(&quot;CustomerID&quot;);
        &#x2F;&#x2F; Validates that the value of the CustomerID property on Customer is a Guid.
        customerIdProperty.validators.push(Validator.guid());
    @method guid
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.guid = function () {
        var valFn = function (v) {
            if (v == null) return true;
            return __isGuid(v);
        };
        return new ctor(&quot;guid&quot;, valFn);
    };

    &#x2F;**
    Returns a ISO 8601 duration string  Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var eventType = em1.metadataStore.getEntityType(&quot;Event&quot;);
        var elapsedTimeProperty - eventType.getProperty(&quot;ElapsedTime&quot;);
        &#x2F;&#x2F; Validates that the value of the ElapsedTime property on Customer is a duration.
        elapsedTimeProperty.validators.push(Validator.duration());
    @method duration
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.duration = function() {
        var valFn = function(v) {
            if (v == null) return true;
            return __isDuration(v);
        };
        return new ctor(&quot;duration&quot;, valFn);
    };

    &#x2F;**
    Returns a standard numeric data type Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
        var freightProperty - orderType.getProperty(&quot;Freight&quot;);
        &#x2F;&#x2F; Validates that the value of the Freight property on Order is a number.
        freightProperty.validators.push(Validator.number());
    @method number 
    @static
    @return {Validator} A new Validator
    **&#x2F;

    &#x2F;&#x2F; TODO: may need to have seperate logic for single.
    ctor.number = ctor.double = ctor.single = function (context) {
        var valFn = function (v, ctx) {
            if (v == null) return true;
            if (typeof v === &quot;string&quot; &amp;&amp; ctx &amp;&amp; ctx.allowString) {
                v = parseInt(v, 10);
            }
            return (typeof v === &quot;number&quot; &amp;&amp; !isNaN(v));
        };
        return new ctor(&quot;number&quot;, valFn, context);
    };

    &#x2F;**
    Returns a standard large integer data type - 64 bit - Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
        var freightProperty - orderType.getProperty(&quot;Freight&quot;);
        &#x2F;&#x2F; Validates that the value of the Freight property on Order is within the range of a 64 bit integer.
        freightProperty.validators.push(Validator.int64());
    @method int64
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.integer = ctor.int64 = function (context) {
        var valFn = function (v, ctx) {
            if (v == null) return true;
            if (typeof v === &quot;string&quot; &amp;&amp; ctx &amp;&amp; ctx.allowString) {
                v = parseInt(v, 10);
            }
            return (typeof v === &quot;number&quot;) &amp;&amp; (!isNaN(v)) &amp;&amp; Math.floor(v) === v;
        };
        return new ctor(&quot;integer&quot;, valFn, context );
    };

    &#x2F;**
    Returns a standard 32 bit integer data type Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
        var freightProperty - orderType.getProperty(&quot;Freight&quot;);
        freightProperty.validators.push(Validator.int32());
    @method int32
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.int32 = function(context) {
        return intRangeValidatorCtor(&quot;int32&quot;, INT32_MIN, INT32_MAX, context)();
    };

    &#x2F;**
    Returns a standard 16 bit integer data type Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
        var freightProperty - orderType.getProperty(&quot;Freight&quot;);
        &#x2F;&#x2F; Validates that the value of the Freight property on Order is within the range of a 16 bit integer.
        freightProperty.validators.push(Validator.int16());
    @method int16
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.int16 = function (context) {
        return intRangeValidatorCtor(&quot;int16&quot;, INT16_MIN, INT16_MAX, context)();
    };

    &#x2F;**
    Returns a standard byte data type Validator. (This is a integer between 0 and 255 inclusive for js purposes).
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
        var freightProperty - orderType.getProperty(&quot;Freight&quot;);
        &#x2F;&#x2F; Validates that the value of the Freight property on Order is within the range of a 16 bit integer.
        &#x2F;&#x2F; Probably not a very good validation to place on the Freight property.
        regionProperty.validators.push(Validator.byte());
    @method byte
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.byte = function (context) {
        return intRangeValidatorCtor(&quot;byte&quot;, BYTE_MIN, BYTE_MAX, context)();
    };

    &#x2F;**
    Returns a standard boolean data type Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var productType = em1.metadataStore.getEntityType(&quot;Product&quot;);
        var discontinuedProperty - productType.getProperty(&quot;Discontinued&quot;);
        &#x2F;&#x2F; Validates that the value of the Discontinued property on Product is a boolean
        discontinuedProperty.validators.push(Validator.bool());
    @method bool
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.bool = function () {
        var valFn = function (v) {
            if (v == null) return true;
            return (v === true) || (v === false);
        };
        return new ctor(&quot;bool&quot;, valFn );
    };

    ctor.none = function () {
        var valFn = function (v) {
            return true;
        };
        return new ctor(&quot;none&quot;, valFn);
    };

    &#x2F;**
    Returns a standard date data type Validator.
    @example
        &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
        var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
        var orderDateProperty - orderType.getProperty(&quot;OrderDate&quot;);
        &#x2F;&#x2F; Validates that the value of the OrderDate property on Order is a date
        &#x2F;&#x2F; Probably not a very good validation to place on the Freight property.
        orderDateProperty.validators.push(Validator.date());
    @method date
    @static
    @return {Validator} A new Validator
    **&#x2F;
    ctor.date = function () {
        var valFn = function (v) {
            if (v == null) return true;
            if (typeof v === &quot;string&quot;) {
                try {
                    return !isNaN(Date.parse(v));
                    &#x2F;&#x2F; old code
                    &#x2F;&#x2F; return __isDate(new Date(v));
                } catch (e) {
                    return false;
                }
            } else {
                return __isDate(v);
            }
        };
        return new ctor(&quot;date&quot;, valFn );
    };

    &#x2F;**
    Returns a credit card number validator
    Performs a luhn algorithm checksum test for plausability
    catches simple mistakes; only service knows for sure
    @example
        &#x2F;&#x2F; Assume em is a preexisting EntityManager.
        var personType = em.metadataStore.getEntityType(&quot;Person&quot;);
        var creditCardProperty = personType.getProperty(&quot;creditCard&quot;);
        &#x2F;&#x2F; Validates that the value of the Person.creditCard property is credit card.
        creditCardProperty.validators.push(Validator.creditCard());
    @method creditCard
    @static
    @param [context] {Object} optional parameters to pass through to validation constructor
    @return {Validator} A new Validator
    **&#x2F;
    ctor.creditCard = function(context) {
        function valFn(v) {
            if (v == null || v === &#x27;&#x27;) return true;
            if (typeof (v) !== &#x27;string&#x27;) return false;
            v = v.replace(&#x2F;(\-|\s)&#x2F;g, &quot;&quot;); &#x2F;&#x2F; remove dashes and spaces
            if (!v || &#x2F;\D&#x2F;.test(v)) return false; &#x2F;&#x2F; all digits, not empty
            return luhn(v);
        };
        return new ctor(&#x27;creditCard&#x27;, valFn, context);
    };

    &#x2F;&#x2F; http:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Luhn_test_of_credit_card_numbers#JavaScript
    function luhn(a, b, c, d, e) {
        for (d = +a[b = a.length - 1], e = 0; b--;)
            c = +a[b], d += ++e % 2 ? 2 * c % 10 + (c &gt; 4) : c;
        return !(d % 10);
    };

    &#x2F;**
    Returns a regular expression validator; the expression must be specified
    @example
        &#x2F;&#x2F; Add validator to a property. Assume em is a preexisting EntityManager.
        var customerType = em.metadataStore.getEntityType(&quot;Customer&quot;);
        var regionProperty = customerType.getProperty(&quot;Region&quot;);
        &#x2F;&#x2F; Validates that the value of Customer.Region is 2 char uppercase alpha.
        regionProperty.validators.push(Validator.regularExpression( {expression: &#x27;^[A-Z]{2}$&#x27;} );
    @method regularExpression
    @static
    @param context {Object} 
    @param context.expression {String} String form of the regular expression to apply
    @return {Validator} A new Validator
    **&#x2F;
    ctor.regularExpression = function(context) {
        function valFn(v, ctx) {
            &#x2F;&#x2F; do not invalidate if empty; use a separate required test
            if (v == null || v === &#x27;&#x27;) return true;
            if (typeof (v) !== &#x27;string&#x27;) return false;
            try {
                var re = new RegExp(ctx.expression);
            } catch (e) {
                throw new Error(&#x27;Missing or invalid expression parameter to regExp validator&#x27;);
            }
            return re.test(v);
        };
        return new ctor(&#x27;regularExpression&#x27;, valFn, context);
    };

    &#x2F;**
    Returns the email address validator
    @example
        &#x2F;&#x2F; Assume em is a preexisting EntityManager.
        var personType = em.metadataStore.getEntityType(&quot;Person&quot;);
        var emailProperty = personType.getProperty(&quot;email&quot;);
        &#x2F;&#x2F; Validates that the value of the Person.email property is an email address.
        emailProperty.validators.push(Validator.emailAddress());
    @method emailAddress
    @static
    @param [context] {Object} optional parameters to pass through to validation constructor
    @return {Validator} A new Validator
    **&#x2F;
    ctor.emailAddress = function(context) {
        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;srkirkland&#x2F;DataAnnotationsExtensions&#x2F;blob&#x2F;master&#x2F;DataAnnotationsExtensions&#x2F;EmailAttribute.cs
        var reEmailAddress = &#x2F;^((([a-z]|\d|[!#\$%&amp;&#x27;\*\+\-\&#x2F;=\?\^_&#x60;{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&amp;&#x27;\*\+\-\&#x2F;=\?\^_&#x60;{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$&#x2F;;
        return makeRegExpValidator(&#x27;emailAddress&#x27;, reEmailAddress, null, context);
    };

    &#x2F;**
    Returns the phone validator
    Provides basic assertions on the format and will help to eliminate most nonsense input
    Matches:
      International dialing prefix: {{}, +, 0, 0000} (with or without a trailing break character, if not &#x27;+&#x27;: [-&#x2F;. ])
        &gt; ((\+)|(0(\d+)?[-&#x2F;.\s]))
      Country code: {{}, 1, ..., 999} (with or without a trailing break character: [-&#x2F;. ])
        &gt; [1-9]\d{,2}[-&#x2F;.\s]?
      Area code: {(0), ..., (000000), 0, ..., 000000} (with or without a trailing break character: [-&#x2F;. ])
        &gt; ((\(\d{1,6}\)|\d{1,6})[-&#x2F;.\s]?)?
      Local: {0, ...}+ (with or without a trailing break character: [-&#x2F;. ])
        &gt; (\d+[-&#x2F;.\s]?)+\d+
    @example
        &#x2F;&#x2F; Assume em is a preexisting EntityManager.
        var customerType = em.metadataStore.getEntityType(&quot;Customer&quot;);
        var phoneProperty = customerType.getProperty(&quot;phone&quot;);
        &#x2F;&#x2F; Validates that the value of the Customer.phone property is phone.
        phoneProperty.validators.push(Validator.phone());
    @method phone
    @static
    @param [context] {Object} optional parameters to pass through to validation constructor
    @return {Validator} A new Validator
    **&#x2F;
    ctor.phone = function(context) {
        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;srkirkland&#x2F;DataAnnotationsExtensions&#x2F;blob&#x2F;master&#x2F;DataAnnotationsExtensions&#x2F;Expressions.cs
        var rePhone = &#x2F;^((\+|(0(\d+)?[-&#x2F;.\s]?))[1-9]\d{0,2}[-&#x2F;.\s]?)?((\(\d{1,6}\)|\d{1,6})[-&#x2F;.\s]?)?(\d+[-&#x2F;.\s]?)+\d+$&#x2F;;
        return makeRegExpValidator(&#x27;phone&#x27;, rePhone, null, context);
    };

    &#x2F;**
    Returns the URL (protocol required) validator
    @example
        &#x2F;&#x2F; Assume em is a preexisting EntityManager.
        var personType = em.metadataStore.getEntityType(&quot;Person&quot;);
        var websiteProperty = personType.getProperty(&quot;website&quot;);
        &#x2F;&#x2F; Validates that the value of the Person.website property is a URL.
        websiteProperty.validators.push(Validator.url());
    @method url
    @static
    @param [context] {Object} optional parameters to pass through to validation constructor
    @return {Validator} A new Validator
    **&#x2F;
    ctor.url = function(context) {
        &#x2F;&#x2F;See https:&#x2F;&#x2F;github.com&#x2F;srkirkland&#x2F;DataAnnotationsExtensions&#x2F;blob&#x2F;master&#x2F;DataAnnotationsExtensions&#x2F;UrlAttribute.cs
        var reUrlProtocolRequired = &#x2F;^(https?|ftp):\&#x2F;\&#x2F;(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|([a-zA-Z][\-a-zA-Z0-9]*)|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\&#x2F;((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)+(\&#x2F;(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\&#x2F;|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&amp;&#x27;\(\)\*\+,;=]|:|@)|\&#x2F;|\?)*)?$&#x2F;;
        return makeRegExpValidator(&#x27;url&#x27;, reUrlProtocolRequired, null, context);
    };

    &#x2F;**
    Creates a regular expression validator with a fixed expression.
    Many of the stock validators are built with this factory method.
    Their expressions are often derived from 
    https:&#x2F;&#x2F;github.com&#x2F;srkirkland&#x2F;DataAnnotationsExtensions&#x2F;blob&#x2F;master&#x2F;DataAnnotationsExtensions
    You can try many of them at http:&#x2F;&#x2F;dataannotationsextensions.org&#x2F;
    @example
        &#x2F;&#x2F; Make a zipcode validator
        function zipValidator = Validator.makeRegExpValidator(
            &quot;zipVal,  
            &#x2F;^\d{5}([\-]\d{4})?$&#x2F;,  
            &quot;The %displayName% &#x27;%value%&#x27; is not a valid U.S. zipcode&quot;);
        &#x2F;&#x2F; Register it.
        Validator.register(zipValidator);
        &#x2F;&#x2F; Add it to a data property. Assume em is a preexisting EntityManager.
        var custType = em.metadataStore.getEntityType(&quot;Customer&quot;);
        var zipProperty = custType.getProperty(&quot;PostalCode&quot;);
        zipProperty.validators.push(zipValidator);
    @method makeRegExpValidator
    @static
    @param validatorName {String} name of this validator
    @param expression {String | RegExp} regular expression to apply
    @param [defaultMessage] {String} default message for failed validations
    @param [context] {Object} optional parameters to pass through to validation constructor
    @return {Validator} A new Validator
    **&#x2F;
    ctor.makeRegExpValidator = makeRegExpValidator;

    function makeRegExpValidator(validatorName, expression, defaultMessage, context) {
        if (defaultMessage) {
            ctor.messageTemplates[validatorName] = defaultMessage;
        }
        var re = (typeof (expression) === &#x27;string&#x27;) ? new RegExp(expression) : expression;
        var valFn = function(v) {
            &#x2F;&#x2F; do not invalidate if empty; use a separate required test
            if (v == null || v === &#x27;&#x27;) return true;
            if (typeof (v) !== &#x27;string&#x27;) return false;
            return re.test(v);
        };
        return new ctor(validatorName, valFn, context);
    };
    
    &#x2F;&#x2F; register all validators
    __objectForEach(ctor, function (key, value) {
        if (typeof (value) !== &quot;function&quot;) {
            return;
        }
        if (key === &quot;fromJSON&quot; || key === &quot;register&quot; ||
            key === &quot;registerFactory&quot; || key === &quot;makeRegExpValidator&quot;) {
            return;
        }

        __config.registerFunction(value, &quot;Validator.&quot; + key);
    });


    &#x2F;&#x2F; private funcs

    function formatTemplate(template, vars, ownPropertiesOnly) {
        if (!vars) return template;
        return template.replace(&#x2F;%([^%]+)%&#x2F;g, function (_, key) {
            var valOrFn;
            if (ownPropertiesOnly) {
                valOrFn = vars.hasOwnProperty(key) ? vars[key] : &#x27;&#x27;;
            } else {
                valOrFn = vars[key];
            }
            if (valOrFn) {
                if (__isFunction(valOrFn)) {
                    return valOrFn(vars);
                } else {
                    return valOrFn;
                }
            } else {
                return &quot;&quot;;
            }
        });
    }

    function intRangeValidatorCtor(validatorName, minValue, maxValue, context) {
        ctor.messageTemplates[validatorName] = __formatString(&quot;&#x27;%displayName%&#x27; must be an integer between the values of %1 and %2&quot;,
            minValue, maxValue);
        return function () {
            var valFn = function (v, ctx) {
                if (v == null) return true;
                if (typeof v === &quot;string&quot; &amp;&amp; ctx &amp;&amp; ctx.allowString)  {
                    v = parseInt(v, 0);
                }
                if ((typeof v === &quot;number&quot;) &amp;&amp; (!isNaN(v)) &amp;&amp; Math.floor(v) === v) {
                    if (minValue != null &amp;&amp; v &lt; minValue) {
                        return false;
                    }
                    if (maxValue != null &amp;&amp; v &gt; maxValue) {
                        return false;
                    }
                    return true;
                } else {
                    return false;
                }
            };
            return new ctor(validatorName, valFn, context);
        };
    }

    return ctor;
}) ();

var ValidationError = (function () {
    &#x2F;**
    A ValidationError is used to describe a failed validation.

    @class ValidationError
    **&#x2F;
        
    &#x2F;**
    Constructs a new ValidationError
    @method &lt;ctor&gt; ValidationError

    @param validator {Validator || null} The Validator used to create this error, if any.
    @param context { ContextObject || null) The Context object used in conjunction with the Validator to create this error.
    @param errorMessage { String} The actual error message
    @param [key] {String} An optional key used to define a key for this error. One will be created automatically if not provided here. 
    **&#x2F;
    var ctor = function (validator, context, errorMessage, key) {
        assertParam(validator, &quot;validator&quot;).isOptional().isInstanceOf(Validator).check();
        assertParam(errorMessage, &quot;errorMessage&quot;).isNonEmptyString().check();
        assertParam(key, &quot;key&quot;).isOptional().isNonEmptyString().check();
        this.validator = validator;
        var context = context || {};
        this.context = context;
        this.errorMessage = errorMessage;
        
        this.property = context.property 
        this.propertyName = context.propertyName || (context.property &amp;&amp; context.property.name);
        
        if (key) {
            this.key = key;
        } else {
            this.key = ValidationError.getKey(validator || errorMessage, this.propertyName);
        }
        this.isServerError = false;
    };

        
    &#x2F;**
    The Validator associated with this ValidationError.

    __readOnly__
    @property validator {Validator}
    **&#x2F;
        
    &#x2F;**
    A &#x27;context&#x27; object associated with this ValidationError.

    __readOnly__
    @property context {Object}
    **&#x2F;
        
    &#x2F;**
    The DataProperty or NavigationProperty associated with this ValidationError.

    __readOnly__
    @property property {DataProperty|NavigationProperty}
    **&#x2F;
        
    &#x2F;**
    The property name associated with this ValidationError. This will be a &quot;property path&quot; for any properties of a complex object.

    __readOnly__
    @property propertyName {String}
    **&#x2F;
        
    &#x2F;**
    The error message associated with the ValidationError.

    __readOnly__
    @property errorMessage {string}
    **&#x2F;

    &#x2F;**
    The key by which this validation error may be removed from a collection of ValidationErrors.

    __readOnly__
    @property key {string}
    **&#x2F;

    &#x2F;**
   Whether this is a server error.  

   __readOnly__
   @property isServerError {bool}
   **&#x2F;


    &#x2F;**
    Composes a ValidationError &#x27;key&#x27; given a validator or an errorName and an optional propertyName
    @method getKey
    @static
    @param validator {ValidatorOrErrorKey} A Validator or an &quot;error name&quot; if no validator is available.
    @param [propertyName] A property name
    @return {String} A ValidationError &#x27;key&#x27;
    **&#x2F;
    ctor.getKey = function (validatorOrErrorName, propertyName) {
        return (validatorOrErrorName.name || validatorOrErrorName) + (propertyName ? &quot;:&quot; + propertyName : &quot;&quot;);
        &#x2F;&#x2F; return (propertyName || &quot;&quot;) + &quot;:&quot; + (validator.name || validator);
    };


    return ctor;
})();
    
breeze.Validator = Validator;
breeze.ValidationError = ValidationError;
 

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="primary-nav-foot">
	<ul>
		<li>
			<a href="http://www.breezejs.com/documentation/download" target="_blank">Download</a></li>
		<li>
			<a href="http://learn.breezejs.com/" target="_blank">Tutorials</a></li>	
		<li>
			<a href="http://www.breezejs.com/documentation/introduction">Docs</a></li>
		<li>
			<a href="http://www.breezejs.com/samples">Samples</a></li>
		<li>
			<a href="http://www.breezejs.com/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://stackoverflow.com/questions/tagged/breeze?sort=newest" target="_blank">Forum</a></li>
		<li>
			<a href="http://www.breezejs.com/support" target="_blank">Support</a></li>
	</ul>
</div>
</div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
