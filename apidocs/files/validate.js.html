<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>validate.js - The Breeze API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
<!-- commenting out until beta goes live	<link rel="stylesheet" href="http://breezejs.com/sites/all/themes/omega/alpha/css/apha-reset.css"> 
-->    
	<link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<script type="text/javascript">
  var uvOptions = {};
  (function() {
    var uv = document.createElement('script'); uv.type = 'text/javascript'; uv.async = true;
    uv.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'widget.uservoice.com/GHug452CgVREu58xjoDg.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(uv, s);
  })();
</script>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34729465-1']);
  _gaq.push(['_setDomainName', 'breezejs.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>




<div id="wrap">

<div id="doc">
<div class="header">
<div class="logo">
	<a href="http://www.breezejs.com/home"><img src="http://www.breezejs.com/sites/all/themes/breeze/images/breeze.png" /></a>
	</div>

    <div class="primary-nav">
<ul>
		<li>
			<a href="/home">Home</a></li>
		<li>
			<a href="http://www.breezejs.com/documentation/download">Download</a></li>
		<li>
			<a href="/samples">Samples</a></li>
		<li>
			<a href="/documentation/introduction">Docs</a></li>
		<li>
			<a href="/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.ideablade.com/forum/" target="_blank">Forum</a></li>
		<li>
			<a href="/contact">Contact</a></li>
	</ul>
</div>
</div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/AutoGeneratedKeyType.html">AutoGeneratedKeyType</a></li>
            
                <li><a href="..&#x2F;classes/config.html">config</a></li>
            
                <li><a href="..&#x2F;classes/DataProperty.html">DataProperty</a></li>
            
                <li><a href="..&#x2F;classes/DataType.html">DataType</a></li>
            
                <li><a href="..&#x2F;classes/EntityAction.html">EntityAction</a></li>
            
                <li><a href="..&#x2F;classes/EntityAspect.html">EntityAspect</a></li>
            
                <li><a href="..&#x2F;classes/EntityKey.html">EntityKey</a></li>
            
                <li><a href="..&#x2F;classes/EntityManager.html">EntityManager</a></li>
            
                <li><a href="..&#x2F;classes/EntityQuery.html">EntityQuery</a></li>
            
                <li><a href="..&#x2F;classes/EntityState.html">EntityState</a></li>
            
                <li><a href="..&#x2F;classes/EntityType.html">EntityType</a></li>
            
                <li><a href="..&#x2F;classes/Enum.html">Enum</a></li>
            
                <li><a href="..&#x2F;classes/EnumSymbol.html">EnumSymbol</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/FetchStrategy.html">FetchStrategy</a></li>
            
                <li><a href="..&#x2F;classes/FilterQueryOp.html">FilterQueryOp</a></li>
            
                <li><a href="..&#x2F;classes/MergeStrategy.html">MergeStrategy</a></li>
            
                <li><a href="..&#x2F;classes/MetadataStore.html">MetadataStore</a></li>
            
                <li><a href="..&#x2F;classes/NamingConvention.html">NamingConvention</a></li>
            
                <li><a href="..&#x2F;classes/NavigationProperty.html">NavigationProperty</a></li>
            
                <li><a href="..&#x2F;classes/Predicate.html">Predicate</a></li>
            
                <li><a href="..&#x2F;classes/QueryOptions.html">QueryOptions</a></li>
            
                <li><a href="..&#x2F;classes/SaveOptions.html">SaveOptions</a></li>
            
                <li><a href="..&#x2F;classes/ValidationError.html">ValidationError</a></li>
            
                <li><a href="..&#x2F;classes/ValidationOptions.html">ValidationOptions</a></li>
            
                <li><a href="..&#x2F;classes/Validator.html">Validator</a></li>
            
                <li><a href="..&#x2F;classes/~entityTracking-interface.html">~entityTracking-interface</a></li>
            
                <li><a href="..&#x2F;classes/~keyGenerator-interface.html">~keyGenerator-interface</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
                <li><a href="..&#x2F;modules/entityModel.html">entityModel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: validate.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿define([&quot;core&quot;],
function (core) {
    &quot;use strict&quot;;
    &#x2F;**
    @module entityModel
    **&#x2F;

    var assertParam = core.assertParam;

    var Validator = function () {

        var INT16_MIN = -32768;
        var INT16_MAX = 32767;

        var INT32_MIN = -2147483648;
        var INT32_MAX = 2147483647;

        var BYTE_MIN = 0;
        var BYTE_MAX = 255;

        &#x2F;&#x2F; add common props and methods for every validator &#x27;context&#x27; here.
        var rootContext = {
            displayName: function (context) {
                if (context.property) {
                    return context.property.displayName || context.property.name;
                } else {
                    return &quot;Value&quot;;
                }
            }
        };

        &#x2F;**
        Instances of the Validator class provide the logic to validate another object and provide a description of any errors
        encountered during the validation process.  They are typically associated with a &#x27;validators&#x27; property on the following types: {{#crossLink &quot;EntityType&quot;}}{{&#x2F;crossLink}}, 
        {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}} or {{#crossLink &quot;NavigationProperty&quot;}}{{&#x2F;crossLink}}.
        
        A number of property level validators are registered automatically, i.e added to each DataProperty.validators property 
        based on {{#crossLink &quot;DataProperty&quot;}}{{&#x2F;crossLink}} metadata.  For example, 
        
        - DataProperty.dataType -&gt; one of the &#x27;dataType&#x27; validator methods such as Validator.int64, Validator.date, Validator.bool etc.
        - DataProperty.maxLength -&gt; Validator.maxLength 
        - DataProperty.isNullable -&gt; Validator.required (if not nullable)

        @class Validator
        **&#x2F;
        
        &#x2F;**
        Validator constructor - This method is used to create create custom validations.  Several
        basic &quot;Validator&quot; construction methods are also provided as static methods to this class. These methods
        provide a simpler syntax for creating basic validations.

        However, sometimes a custom validator will be required.
        @example
        Most validators will be &#x27;property&#x27; level validators, like this.
        @example
            &#x2F;&#x2F; v is this function is the value to be validated, in this case a &quot;country&quot; string.
            var valFn = function (v) {
                if (v == null) return true;
                return (core.stringStartsWith(v, &quot;US&quot;));
            };
            var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, { 
                displayName: &quot;Country&quot;, 
                messageTemplate: &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot; 
            });

            &#x2F;&#x2F; Now plug it into Breeze.
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = metadataStore.getEntityType(&quot;Customer&quot;);
            var countryProp = custType.getProperty(&quot;Country&quot;);
            &#x2F;&#x2F; Note that validator is added to a &#x27;DataProperty&#x27; validators collection.
            prop.validators.push(countryValidator);
        Entity level validators are also possible
        @example
            function isValidZipCode(value) {
                var re = &#x2F;^\d{5}([\-]\d{4})?$&#x2F;;
                return (re.test(value));
            }               
           
            &#x2F;&#x2F; v in this case will be a Customer entity
            var valFn = function (v) {
                &#x2F;&#x2F; This validator only validates US Zip Codes.
                if ( v.getProperty(&quot;Country&quot;) === &quot;USA&quot;) {
                    var postalCode = v.getProperty(&quot;PostalCode&quot;);
                    return isValidZipCode(postalCode);
                }
                return true;
            };
            var zipCodeValidator = new Validator(&quot;zipCodeValidator&quot;, valFn, 
                { messageTemplate: &quot;For the US, this is not a valid PostalCode&quot; });
        
            &#x2F;&#x2F; Now plug it into Breeze.
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
            &#x2F;&#x2F; Note that validator is added to an &#x27;EntityType&#x27; validators collection.
            custType.validators.push(zipCodeValidator);
        What is commonly needed is a way of creating a parameterized function that will itself
        return a new Validator.  This requires the use of a &#x27;context&#x27; object.
        @example
            &#x2F;&#x2F; create a function that will take in a config object
            &#x2F;&#x2F; and will return a validator
            var numericRangeValidator = function(context) {
                var valFn = function(v, ctx) {
                    if (v == null) return true;
                    if (typeof(v) !== &quot;number&quot;) return false;
                    if (ctx.min != null &amp;&amp; v &lt; ctx.min) return false;
                    if (ctx.max != null &amp;&amp; v &gt; ctx.max) return false;
                    return true;
                };
                &#x2F;&#x2F; The last parameter below is the &#x27;context&#x27; object that will be passed into the &#x27;ctx&#x27; parameter above
                &#x2F;&#x2F; when this validator executes. Several other properties, such as displayName will get added to this object as well.
                return new Validator(&quot;numericRange&quot;, valFn, {
                    messageTemplate: &quot;&#x27;%displayName%&#x27; must be an integer between the values of %min% and %max%&quot;,
                    min: context.min,
                    max: context.max
                });
            };
            &#x2F;&#x2F; Assume that freightProperty is a DataEntityProperty that describes numeric values.
            &#x2F;&#x2F; register the validator
            freightProperty.validators.push(numericRangeValidator({ min: 100, max: 500 }));

        @method &lt;ctor&gt; Validator
        @param name {String} The name of this validator.
        @param valFn {validatorFunction} A function to perform validation.
            
        validatorFunction(value, context)
        @param valFn.value {Object} Value to be validated
        @param valFn.context {Object} The same context object passed into the constructor with the following additonal properties if not 
        otherwise specified.
        @param valFn.context.value {Object} The value being validated.
        @param valFn.context.validatorName {String} The name of the validator being executed.
        @param valFn.context.displayName {String} This will be either the value of the property&#x27;s &#x27;displayName&#x27; property or
        the value of its &#x27;name&#x27; property or the string &#x27;Value&#x27;
        @param valFn.context.messageTemplate {String} This will either be the value of Validator.messageTemplates[ {this validators name}] or null. Validator.messageTemplates
        is an object that is keyed by validator name and that can be added to in order to &#x27;register&#x27; your own message for a given validator. 
        The following property can also be specified for any validator to force a specific errorMessage string
        @param [valFn.context.message] {String} If this property is set it will be used instead of the &#x27;messageTemplate&#x27; property when an
        error message is generated. 
                    
        @param [context] {Object} A free form object whose properties will made available during the validation and error message creation process.
        This object will be passed into the Validator&#x27;s validation function whenever &#x27;validate&#x27; is called. See above for a description
        of additional properties that will be automatically added to this object if not otherwise specified. 
        **&#x2F;
        var ctor = function (name, valFn, context) {
            &#x2F;&#x2F; _baseContext is what will get serialized 
            this._baseContext = context || {};
            this._baseContext.validatorName = name;
            context = core.extend(Object.create(rootContext), this._baseContext);
            context.messageTemplate = context.messageTemplate || ctor.messageTemplates[name];
            this.name = name;
            this.valFn = valFn;
            this.context = context;
        };


        &#x2F;**
        Run this validator against the specified value.  This method will usually be called internally either
        automatically by an property change, entity attach, query or save operation, or manually as a result of
        a validateEntity call on the EntityAspect. The resulting ValidationResults are available via the 
        EntityAspect.getValidationErrors method.

        However, you can also call a validator directly either for testing purposes or some other reason if needed.
        @example
            &#x2F;&#x2F; using one of the predefined validators
            var validator = Validator.maxLength({ maxLength: 5, displayName: &quot;City&quot; });
            &#x2F;&#x2F; should be ok because &quot;asdf&quot;.length &lt; 5
            var result = validator.validate(&quot;asdf&quot;);
            ok(result === null);
            result = validator.validate(&quot;adasdfasdf&quot;);
            &#x2F;&#x2F; extract all of the properties of the &#x27;result&#x27;
            var errMsg = result.errorMessage;
            var context = result.context;
            var sameValidator = result.validator;
        @method validate
        @param value {Object} Value to validate
        @param additionalContext {Object} Any additional contextual information that the Validator
        can make use of.
        @return {ValidationError|null} A ValidationError if validation fails, null otherwise
        **&#x2F;
        ctor.prototype.validate = function (value, additionalContext) {
            var currentContext;
            if (additionalContext) {
                currentContext = core.extend(Object.create(this.context), additionalContext);
            } else {
                currentContext = this.context;
            }
            this.currentContext = currentContext;
            if (!this.valFn(value, currentContext)) {
                currentContext.value = value;
                var valContext = {
                    property: currentContext.property,
                    value: value
                };
                return new ValidationError(this, valContext, this.getMessage());
            }
            return null;
        };


        &#x2F;&#x2F; context.value is not avail unless validate was called first.

        &#x2F;**
        Returns the message generated by the most recent execution of this Validator.
        @example
            var v0 = Validator.maxLength({ maxLength: 5, displayName: &quot;City&quot; });
            v0.validate(&quot;adasdfasdf&quot;);
            var errMessage = v0.getMessage());
        @method getMessage
        @return {String}
        **&#x2F;
        ctor.prototype.getMessage = function () {
            try {
                var context = this.currentContext;
                var message = context.message;
                if (message) {
                    if (typeof (message) == &quot;function&quot;) {
                        return message(context);
                    } else {
                        return message;
                    }
                } else if (context.messageTemplate) {
                    return formatTemplate(context.messageTemplate, context);
                } else {
                    return &quot;invalid value: &quot; + this.validatorName || &quot;{unnamed validator}&quot;;
                }
            } catch (e) {
                return &quot;Unable to format error message&quot; + e.toString();
            }
        };

        ctor.prototype.toJSON = function () {
            return this._baseContext;
        };

        ctor.fromJSON = function (json) {
            var validatorName = &quot;Validator.&quot; + json.validatorName;
            var fn = core.config.functionRegistry[validatorName];
            return fn(json);
        };

        &#x2F;**
        Map of standard error message templates keyed by validator name.
        You can add to or modify this object to customize the template used for any validation error message.
        @example
            &#x2F;&#x2F; v is this function is the value to be validated, in this case a &quot;country&quot; string.
            var valFn = function (v) {
                if (v == null) return true;
                return (core.stringStartsWith(v, &quot;US&quot;));
            };
            var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, { displayName: &quot;Country&quot; }); 
            Validator.messageTemplates[&quot;countryIsUS&quot;, &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot;);
        This will have a similar effect to this
             var countryValidator = new Validator(&quot;countryIsUS&quot;, valFn, { 
                displayName: &quot;Country&quot;, 
                messageTemplate: &quot;&#x27;%displayName%&#x27; must start with &#x27;US&#x27;&quot; 
            });
        @property messageTemplates {Object}
        @static
        **&#x2F;
        ctor.messageTemplates = {
            required: &quot;&#x27;%displayName%&#x27; is required&quot;,
            date: &quot;&#x27;%displayName%&#x27; must be a date&quot;,
            string: &quot;&#x27;%displayName%&#x27; must be a string&quot;,
            bool: &quot;&#x27;%displayName%&#x27; must be a &#x27;true&#x27; or &#x27;false&#x27; value&quot;,
            guid: &quot;&#x27;%displayName%&#x27; must be a GUID&quot;,
            number: &quot;&#x27;%displayName%&#x27; must be a number&quot;,
            integer: &quot;&#x27;%displayName%&#x27; must be an integer&quot;,
            integerRange: &quot;&#x27;%displayName%&#x27; must be an integer between the values of %minValue% and %maxValue%&quot;,
            maxLength: &quot;&#x27;%displayName%&#x27; must be a string with less than %maxLength% characters&quot;,
            stringLength: &quot;&#x27;%displayName%&#x27; must be a string with between %minLength% and %maxLength% characters&quot;
        };

        &#x2F;**
        Returns a standard &#x27;required value&#x27; Validator
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
            var regionProperty - custType.getProperty(&quot;Region&quot;);
            &#x2F;&#x2F; Makes &quot;Region&quot; on Customer a required property.
            regionProperty.validators.push(Validator.required());
        @method required
        @static
        @return A new Validator
        **&#x2F;
        ctor.required = function () {
            var valFn = function (v, ctx) {
                if (typeof v === &quot;string&quot;) {
                    if (ctx &amp;&amp; ctx.allowEmptyStrings) return true;
                    return v.length &gt; 0;
                } else {
                    return v != null;
                }
            };
            return new ctor(&quot;required&quot;, valFn);
        };

        &#x2F;**
        Returns a standard maximum string length Validator; the maximum length must be specified
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
            var regionProperty - custType.getProperty(&quot;Region&quot;);
            &#x2F;&#x2F; Validates that the value of the Region property on Customer will be less than or equal to 5 characters.
            regionProperty.validators.push(Validator.maxLength( {maxLength: 5}));
        @method maxLength
        @static
        @param context {Object} 
        @param context.maxLength {Integer}
        @return A new Validator
        **&#x2F;
        ctor.maxLength = function (context) {
            var valFn = function (v, ctx) {
                if (v == null) return true;
                if (typeof (v) != &quot;string&quot;) return false;
                return v.length &lt;= ctx.maxLength;
            };
            return new ctor(&quot;maxLength&quot;, valFn, context);
        };

        &#x2F;**
        Returns a standard maximum string length Validator; both minimum and maximum lengths must be specified.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
            var regionProperty - custType.getProperty(&quot;Region&quot;);
            &#x2F;&#x2F; Validates that the value of the Region property on Customer will be 
            &#x2F;&#x2F; between 2 and 5 characters
            regionProperty.validators.push(Validator.stringLength( {minLength: 2, maxLength: 5});
        @method stringLength
        @static
        @param context {Object} 
        @param context.maxLength {Integer}
        @param context.minLength {Integer}
        @return A new Validator
        **&#x2F;
        ctor.stringLength = function (context) {
            var valFn = function (v, ctx) {
                if (v == null) return true;
                if (typeof (v) != &quot;string&quot;) return false;
                if (ctx.minLength != null &amp;&amp; v.length &lt; ctx.minLength) return false;
                if (ctx.maxLength != null &amp;&amp; v.length &gt; ctx.maxLength) return false;
                return true;
            };
            return new ctor(&quot;stringLength&quot;, valFn, context);
        };

        &#x2F;**
        Returns a standard string dataType Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
            var regionProperty - custType.getProperty(&quot;Region&quot;);
            &#x2F;&#x2F; Validates that the value of the Region property on Customer is a string.
            regionProperty.validators.push(Validator.string());
        @method string
        @static
        @return A new Validator
        **&#x2F;
        ctor.string = function () {
            var valFn = function (v) {
                if (v == null) return true;
                return (typeof v === &quot;string&quot;);
            };
            return new ctor(&quot;string&quot;, valFn );
        };

        &#x2F;**
        Returns a standard string data type Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var custType = em1.metadataStore.getEntityType(&quot;Customer&quot;);
            var customerIdProperty - custType.getProperty(&quot;CustomerID&quot;);
            &#x2F;&#x2F; Validates that the value of the CustomerID property on Customer is a Guid.
            customerIdProperty.validators.push(Validator.guid());
        @method guid
        @static
        @return A new Validator
        **&#x2F;
        ctor.guid = function () {
            var valFn = function (v) {
                if (v == null) return true;
                return core.isGuid(v);
            };
            return new ctor(&quot;guid&quot;, valFn);
        };

        &#x2F;**
        Returns a standard numeric data type Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
            var freightProperty - orderType.getProperty(&quot;Freight&quot;);
            &#x2F;&#x2F; Validates that the value of the Freight property on Order is a number.
            freightProperty.validators.push(Validator.number());
        @method number 
        @static
        @return A new Validator
        **&#x2F;

        &#x2F;&#x2F; TODO: may need to have seperate logic for single.
        ctor.number = ctor.double = ctor.single = function () {
            var valFn = function (v) {
                if (v == null) return true;
                return (typeof v === &quot;number&quot;);
            };
            return new ctor(&quot;number&quot;, valFn);
        };

        &#x2F;**
        Returns a standard large integer data type - 64 bit - Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
            var freightProperty - orderType.getProperty(&quot;Freight&quot;);
            &#x2F;&#x2F; Validates that the value of the Freight property on Order is within the range of a 64 bit integer.
            freightProperty.validators.push(Validator.int64());
        @method int64
        @static
        @return A new Validator
        **&#x2F;
        ctor.integer = ctor.int64 = function () {
            var valFn = function (v) {
                if (v == null) return true;
                return (typeof v === &quot;number&quot;) &amp;&amp; Math.floor(v) === v;
            };
            return new ctor(&quot;integer&quot;, valFn );
        };

        &#x2F;**
        Returns a standard 32 bit integer data type Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
            var freightProperty - orderType.getProperty(&quot;Freight&quot;);
            freightProperty.validators.push(Validator.int32());
        @method int32
        @static
        @return A new Validator
        **&#x2F;
        ctor.int32 = intRangeValidatorCtor(&quot;int32&quot;, INT32_MIN, INT32_MAX);

        &#x2F;**
        Returns a standard 16 bit integer data type Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
            var freightProperty - orderType.getProperty(&quot;Freight&quot;);
            &#x2F;&#x2F; Validates that the value of the Freight property on Order is within the range of a 16 bit integer.
            freightProperty.validators.push(Validator.int16());
        @method int16
        @static
        @return A new Validator
        **&#x2F;
        ctor.int16 = intRangeValidatorCtor(&quot;int16&quot;, INT16_MIN, INT16_MAX);

        &#x2F;**
        Returns a standard byte data type Validator. (This is a integer between 0 and 255 inclusive for js purposes).
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
            var freightProperty - orderType.getProperty(&quot;Freight&quot;);
            &#x2F;&#x2F; Validates that the value of the Freight property on Order is within the range of a 16 bit integer.
            &#x2F;&#x2F; Probably not a very good validation to place on the Freight property.
            regionProperty.validators.push(Validator.byte());
        @method byte
        @static
        @return A new Validator
        **&#x2F;
        ctor.byte = intRangeValidatorCtor(&quot;byte&quot;, BYTE_MIN, BYTE_MAX);

        &#x2F;**
        Returns a standard boolean data type Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var productType = em1.metadataStore.getEntityType(&quot;Product&quot;);
            var discontinuedProperty - productType.getProperty(&quot;Discontinued&quot;);
            &#x2F;&#x2F; Validates that the value of the Discontinued property on Product is a boolean
            discontinuedProperty.validators.push(Validator.bool());
        @method bool
        @static
        @return A new Validator
        **&#x2F;
        ctor.bool = function () {
            var valFn = function (v) {
                if (v == null) return true;
                return (v === true) || (v === false);
            };
            return new ctor(&quot;bool&quot;, valFn );
        };

        ctor.none = function () {
            var valFn = function (v) {
                return true;
            };
            return new ctor(&quot;none&quot;, valFn);
        };

        &#x2F;**
        Returns a standard date data type Validator.
        @example
            &#x2F;&#x2F; Assume em1 is a preexisting EntityManager.
            var orderType = em1.metadataStore.getEntityType(&quot;Order&quot;);
            var orderDateProperty - orderType.getProperty(&quot;OrderDate&quot;);
            &#x2F;&#x2F; Validates that the value of the OrderDate property on Order is a date
            &#x2F;&#x2F; Probably not a very good validation to place on the Freight property.
            orderDateProperty.validators.push(Validator.date());
        @method date
        @static
        @return A new Validator
        **&#x2F;
        ctor.date = function () {
            var valFn = function (v) {
                if (v == null) return true;
                if (typeof v === &quot;string&quot;) {
                    try {
                        return !isNaN(Date.parse(v));
                        &#x2F;&#x2F; old code
                        &#x2F;&#x2F; return core.isDate(new Date(v));
                    } catch (e) {
                        return false;
                    }
                } else {
                    return core.isDate(v);
                }
            };
            return new ctor(&quot;date&quot;, valFn );
        };

        &#x2F;&#x2F; register all validators
        core.objectForEach(ctor, function (key, value) {
            if (typeof (value) !== &quot;function&quot;) {
                return;
            }
            if (key === &quot;fromJSON&quot; || key === &quot;createValidator&quot;) {
                return;
            }

            core.config.registerFunction(value, &quot;Validator.&quot; + key);
        });


        &#x2F;&#x2F; private funcs

        function formatTemplate(template, vars, ownPropertiesOnly) {
            if (!vars) return template;
            return template.replace(&#x2F;%([^%]+)%&#x2F;g, function (_, key) {
                var valOrFn;
                if (ownPropertiesOnly) {
                    valOrFn = vars.hasOwnProperty(key) ? vars[key] : &#x27;&#x27;;
                } else {
                    valOrFn = vars[key];
                }
                if (valOrFn) {
                    if (core.isFunction(valOrFn)) {
                        return valOrFn(vars);
                    } else {
                        return valOrFn;
                    }
                } else {
                    return &quot;&quot;;
                }
            });
        }

        function intRangeValidatorCtor(validatorName, minValue, maxValue) {
            ctor.messageTemplates[validatorName] = core.formatString(&quot;&#x27;%displayName%&#x27; must be an integer between the values of %1 and %2&quot;,
                minValue, maxValue);
            return function () {
                var valFn = function (v, ctx) {
                    if (v == null) return true;
                    if ((typeof v === &quot;number&quot;) &amp;&amp; Math.floor(v) === v) {
                        if (minValue != null &amp;&amp; v &lt; minValue) {
                            return false;
                        }
                        if (maxValue != null &amp;&amp; v &gt; maxValue) {
                            return false;
                        }
                        return true;
                    } else {
                        return false;
                    }
                };
                return new ctor(validatorName, valFn);
            };

        }

        return ctor;
    } ();

    var ValidationError = function () {
         &#x2F;**
        A ValidatationError is used to describe a failed validation.

        @class ValidationError
        **&#x2F;
        
        &#x2F;**
        @method &lt;ctor&gt; ValidationError
        @param validator {Validator}
        @param context {Object}
        @param errorMessage {String}
        **&#x2F;
        var ctor = function (validator, context, errorMessage) {
            assertParam(validator, &quot;validator&quot;).isString().or().isInstanceOf(Validator).check();

            this.validator = validator;
            this.context = context || {};
            this.property = context ? context.property : null;
            this.errorMessage = errorMessage;
            this.key = ValidationError.getKey(validator, this.property);
        };
        
        &#x2F;**
        The Validator associated with this ValidationError.

        __readOnly__
        @property validator {Validator}
        **&#x2F;
        
        &#x2F;**
        A &#x27;context&#x27; object associated with this ValidationError.

        __readOnly__
        @property context {Object}
        **&#x2F;
        
        &#x2F;**
        The DataProperty or NavigationProperty associated with this ValidationError.

        __readOnly__
        @property property {DataProperty|NavigationProperty}
        **&#x2F;
        
        &#x2F;**
        The error message associated with the ValidationError.

        __readOnly__
        @property errorMessage {string}
        **&#x2F;

        ctor.getKey = function (validator, property) {
            return (property ? property.name : &quot;&quot;) + &quot;:&quot; + validator.name;
        };

        return ctor;
    } ();

    return {
        Validator: Validator,
        ValidationError: ValidationError
    };
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="primary-nav-foot">
	<ul>
		<li>
			<a href="/home">Home</a></li>
		<li>
			<a href="http://www.breezejs.com/documentation/download">Download</a></li>
		<li>
			<a href="/samples">Samples</a></li>
		<li>
			<a href="/documentation/introduction">Docs</a></li>
		<li>
			<a href="/sites/all/apidocs/index.html" target="_blank">API</a></li>
		<li>
			<a href="http://www.ideablade.com/forum/" target="_blank">Forum</a></li>
		<li>
			<a href="/contact">Contact</a></li>
	</ul>
</div>
</div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
