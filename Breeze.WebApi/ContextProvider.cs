using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Transactions;
using System.Xml.Linq;
using System.Data;

namespace Breeze.WebApi {
  // Base for EFContextProvider
  public abstract class ContextProvider {

    public IKeyGenerator KeyGenerator { get; set; }

    public static SaveOptions ExtractSaveOptions(dynamic dynSaveBundle) {
      var jsonSerializer = CreateJsonSerializer();

      var dynSaveOptions = dynSaveBundle.saveOptions;
      var saveOptions = (SaveOptions)jsonSerializer.Deserialize(new JTokenReader(dynSaveOptions), typeof(SaveOptions));
      return saveOptions;
    }

    public string Metadata() {
      lock (_metadataLock) {
        if (_jsonMetadata == null) {
          _jsonMetadata = BuildJsonMetadata();
        }

        return _jsonMetadata;
      }
    }

    public static String XDocToJson(XDocument xDoc) {

      var sw = new StringWriter();
      using (var jsonWriter = new JsonPropertyFixupWriter(sw)) {
        // jsonWriter.Formatting = Newtonsoft.Json.Formatting.Indented;
        var jsonSerializer = new JsonSerializer();
        var converter = new XmlNodeConverter();
        jsonSerializer.Converters.Add(converter);
        jsonSerializer.Serialize(jsonWriter, xDoc);
      }

      var jsonText = sw.ToString();
      return jsonText;
    }

    public SaveResult SaveChanges(JObject saveBundle, TransactionSettings transactionSettings = null) {
      var jsonSerializer = CreateJsonSerializer();

      var dynSaveBundle = (dynamic)saveBundle;
      var entitiesArray = (JArray)dynSaveBundle.entities;
      var dynSaveOptions = dynSaveBundle.saveOptions;
      SaveOptions = (SaveOptions) jsonSerializer.Deserialize(new JTokenReader(dynSaveOptions), typeof(SaveOptions));
      transactionSettings = transactionSettings ?? BreezeConfig.Instance.GetTransactionSettings();

      // SaveOptions = ExtractSaveOptions(saveBundle);
      EntitiesWithAutoGeneratedKeys = new List<EntityInfo>();

      var saveMap = new Dictionary<Type, List<EntityInfo>>();
      var jObjects = entitiesArray.Select(jt => (dynamic)jt).ToList();
      var groups = jObjects.GroupBy(jo => (String)jo.entityAspect.entityTypeName).ToList();
      groups.ForEach(g => {
        var entityType = LookupEntityType(g.Key);
        var entityInfos = g.Select(jo => (EntityInfo)CreateEntityInfoFromJson(jo, entityType, jsonSerializer))
          .Where(BeforeSaveEntity)
          .ToList();
        EntitiesWithAutoGeneratedKeys.AddRange(entityInfos.Where(ei => ei.AutoGeneratedKey != null));
        saveMap.Add(entityType, entityInfos);
      });

      List<KeyMapping> keyMappings;
      try
      {
          if (transactionSettings.UseTransactionScope)
          {
              var txOptions = transactionSettings.ToTransactionOptions();
              using (var txScope = new TransactionScope(TransactionScopeOption.Required, txOptions))
              {
                  OpenDbConnection();    // ensure connection is available for BeforeSaveEntities

                  saveMap = BeforeSaveEntities(saveMap);
                  keyMappings = SaveChangesCore(saveMap);
                  AfterSaveEntities(saveMap, keyMappings);

                  txScope.Complete();
              }
          }
          else
          {
              OpenDbConnection();    // ensure connection is available for BeforeSaveEntities
              
              saveMap = BeforeSaveEntities(saveMap);
              keyMappings = SaveChangesCore(saveMap);
              AfterSaveEntities(saveMap, keyMappings);
          }
      }
      finally
      {
          CloseDbConnection();
      }
      
      var entities = saveMap.SelectMany(kvp => kvp.Value.Select(entityInfo => entityInfo.Entity)).ToList();

      return new SaveResult() { Entities = entities, KeyMappings = keyMappings };
    }


    private static JsonSerializer CreateJsonSerializer() {
      var serializerSettings = BreezeConfig.Instance.GetJsonSerializerSettings();
      var jsonSerializer = JsonSerializer.Create(serializerSettings);
      return jsonSerializer;
    }

    #region abstract and virtual methods 

    /// <summary>
    /// Should only be called from BeforeSaveEntities and AfterSaveEntities.
    /// </summary>
    /// <returns>Open DbConnection used by the ContextProvider's implementation</returns>
    public abstract IDbConnection GetDbConnection();

    /// <summary>
    /// Internal use only.  Should only be called by ContextProvider during SaveChanges.
    /// Opens the DbConnection used by the ContextProvider's implementation.
    /// </summary>
    protected abstract void OpenDbConnection();

    /// <summary>
    /// Internal use only.  Should only be called by ContextProvider during SaveChanges.
    /// Closes the DbConnection used by the ContextProvider's implementation.
    /// </summary>
    protected abstract void CloseDbConnection();

    protected abstract String BuildJsonMetadata();
    
    protected abstract List<KeyMapping> SaveChangesCore(Dictionary<Type, List<EntityInfo>> saveMap);

    protected virtual EntityInfo CreateEntityInfo() {
      return new EntityInfo();
    }

    public EntityInfo CreateEntityInfo(Object entity, EntityState entityState = EntityState.Added) {
      var ei = CreateEntityInfo();
      ei.Entity = entity;
      ei.EntityState = entityState;
      return ei;
    }

    public Func<EntityInfo, bool> BeforeSaveEntityDelegate { get; set; }
    public Func<Dictionary<Type, List<EntityInfo>>, Dictionary<Type, List<EntityInfo>>>  BeforeSaveEntitiesDelegate { get; set; }
    public Action<Dictionary<Type, List<EntityInfo>>, List<KeyMapping>> AfterSaveEntitiesDelegate { get; set; }
    
    /// <summary>
    /// The method is called for each entity to be saved before the save occurs.  If this method returns 'false'
    /// then the entity will be excluded from the save. There is no need to call the base implementation of this
    /// method when overriding it. 
    /// </summary>
    /// <param name="entityInfo"></param>
    /// <returns></returns>
    protected virtual bool BeforeSaveEntity(EntityInfo entityInfo) {
      if (BeforeSaveEntityDelegate != null) {
        return BeforeSaveEntityDelegate(entityInfo);
      } else {
        return true;
      }
    }

    protected virtual Dictionary<Type, List<EntityInfo>> BeforeSaveEntities(Dictionary<Type, List<EntityInfo>> saveMap) {
      if (BeforeSaveEntitiesDelegate != null) {
        return BeforeSaveEntitiesDelegate(saveMap);
      } else {
        return saveMap;
      }
    }

    protected virtual void AfterSaveEntities(Dictionary<Type, List<EntityInfo>> saveMap, List<KeyMapping> keyMappings)
    {
        if (AfterSaveEntitiesDelegate != null)
        {
            AfterSaveEntitiesDelegate(saveMap, keyMappings);
        }
    }

    #endregion
    
    protected EntityInfo CreateEntityInfoFromJson(dynamic jo, Type entityType, JsonSerializer jsonSerializer) {
      var entityInfo = CreateEntityInfo();
      
      entityInfo.Entity = jsonSerializer.Deserialize(new JTokenReader(jo), entityType);
      entityInfo.EntityState = (EntityState)Enum.Parse(typeof(EntityState), (String)jo.entityAspect.entityState);


      entityInfo.UnmappedValuesMap = JsonToDictionary(jo.__unmapped);
      entityInfo.OriginalValuesMap = JsonToDictionary(jo.entityAspect.originalValuesMap);

      var autoGeneratedKey = jo.entityAspect.autoGeneratedKey;
      if (entityInfo.EntityState == EntityState.Added && autoGeneratedKey != null) {
        entityInfo.AutoGeneratedKey = new AutoGeneratedKey(entityInfo.Entity, autoGeneratedKey);
      }
      return entityInfo;
    }

    private Dictionary<String, Object> JsonToDictionary(dynamic json) {
      if (json == null) return null;
      var jprops = ((System.Collections.IEnumerable)json).Cast<JProperty>();
      var dict = jprops.ToDictionary(jprop => jprop.Name, jprop => {
        var val = jprop.Value as JValue;
        if (val != null) {
          return val.Value;
        } else {
          return jprop.Value as JObject;
        }
      });
      return dict;
    }

    public SaveOptions SaveOptions { get; set; }

    protected List<EntityInfo> EntitiesWithAutoGeneratedKeys { get; set; }
    
    protected Type LookupEntityType(String entityTypeName) {
      var delims = new string[] { ":#" };
      var parts = entityTypeName.Split(delims, StringSplitOptions.None);
      var shortName = parts[0];
      var ns = parts[1];

      var typeName = ns + "." + shortName;
      var type = BreezeConfig.ProbeAssemblies.Value
        .Select(a => a.GetType(typeName, false, true))
        .FirstOrDefault(t => t != null);
      if (type!=null) {
        return type;
      } else {
        throw new ArgumentException("Assembly could not be found for " + entityTypeName);
      }
    }

    protected static Lazy<Type> KeyGeneratorType = new Lazy<Type>( () => {
       var typeCandidates = BreezeConfig.ProbeAssemblies.Value.Concat( new Assembly[] {typeof(IKeyGenerator).Assembly})
        .SelectMany(a => a.GetTypes()).ToList();
      var generatorTypes = typeCandidates.Where(t => typeof (IKeyGenerator).IsAssignableFrom(t) && !t.IsAbstract)
        .ToList();
      if (generatorTypes.Count == 0) {
        throw new Exception("Unable to locate a KeyGenerator implementation.");
      }
      return generatorTypes.First();
    });

    private object _metadataLock = new object();
    private string _jsonMetadata;
    
  }

  public class SaveOptions {
      public bool AllowConcurrentSaves { get; set; }
      public Object Tag { get; set; }
  }

  public interface IKeyGenerator {
    void UpdateKeys(List<TempKeyInfo> keys);
  }

  // instances of this sent to KeyGenerator
  public class TempKeyInfo {
    public TempKeyInfo(EntityInfo entityInfo) {
      _entityInfo = entityInfo;
    }
    public Object Entity {
      get { return _entityInfo.Entity; }
    }
    public Object TempValue {
      get { return _entityInfo.AutoGeneratedKey.TempValue; }
    }
    public Object RealValue {
      get { return _entityInfo.AutoGeneratedKey.RealValue; }
      set { _entityInfo.AutoGeneratedKey.RealValue = value; }
    }

    public PropertyInfo Property {
      get { return _entityInfo.AutoGeneratedKey.Property; }
    }

    private EntityInfo _entityInfo;

  }

  [Flags]
  public enum EntityState {
    Detached = 1,
    Unchanged = 2,
    Added = 4,
    Deleted = 8,
    Modified = 16,
  }

  public class EntityInfo {
    internal EntityInfo() {
    }

    public Object Entity { get; internal set; }
    public EntityState EntityState { get; internal set; }
    public Dictionary<String, Object> OriginalValuesMap { get; internal set; }
    public bool ForceUpdate { get; set; }
    internal AutoGeneratedKey AutoGeneratedKey;
    public Dictionary<String, Object> UnmappedValuesMap { get; internal set; }
  }

  public enum AutoGeneratedKeyType {
    None,
    Identity,
    KeyGenerator
  }

  public class AutoGeneratedKey {
    public AutoGeneratedKey(Object entity, dynamic autoGeneratedKey) {
      Entity = entity;
      PropertyName = autoGeneratedKey.propertyName;
      AutoGeneratedKeyType = (AutoGeneratedKeyType)Enum.Parse(typeof(AutoGeneratedKeyType), (String)autoGeneratedKey.autoGeneratedKeyType);
      // TempValue and RealValue will be set later. - TempValue during Add, RealValue after save completes.
    }

    public Object Entity;
    public AutoGeneratedKeyType AutoGeneratedKeyType;
    public String PropertyName;
    public PropertyInfo Property {
      get {
        if (_property == null) {
          _property = Entity.GetType().GetProperty(PropertyName,
            BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        }
        return _property;
      }
    }
    public Object TempValue;
    public Object RealValue;
    private PropertyInfo _property;
  }

  // Types returned to javascript as Json.
  public class SaveResult {
    public List<Object> Entities;
    public List<KeyMapping> KeyMappings;
    public String Error;
  }

  public class KeyMapping {
    public String EntityTypeName;
    public Object TempValue;
    public Object RealValue;
  }



  public class JsonPropertyFixupWriter : JsonTextWriter {
    public JsonPropertyFixupWriter(TextWriter textWriter)
      : base(textWriter) {
      _isDataType = false;
    }

    public override void WritePropertyName(string name) {
      if (name.StartsWith("@")) {
        name = name.Substring(1);
      }
      name = ToCamelCase(name);
      _isDataType = name == "type";
      base.WritePropertyName(name);
    }

    public override void WriteValue(string value) {
      if (_isDataType && !value.StartsWith("Edm.")) {
        base.WriteValue("Edm." + value);
      } else {
        base.WriteValue(value);
      }
    }

    private static string ToCamelCase(string s) {
      if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0])) {
        return s;
      }
      string str = char.ToLower(s[0], CultureInfo.InvariantCulture).ToString((IFormatProvider)CultureInfo.InvariantCulture);
      if (s.Length > 1) {
        str = str + s.Substring(1);
      }
      return str;
    }

    private bool _isDataType;


    
  }
 
}